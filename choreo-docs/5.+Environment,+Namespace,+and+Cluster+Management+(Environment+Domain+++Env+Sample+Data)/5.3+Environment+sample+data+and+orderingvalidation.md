## 5.3 Environment Sample Data and Ordering/Validation

This section describes the purpose and usage of the JSON fixtures under

`internal/bundles/environment/env_sample_data/`. These fixtures model various environment promotion chains and are embedded in tests to verify that the `SortEnvironments` function correctly orders environments and handles edge cases (including cycles or missing links).

### Fixture Catalog üìë

| File Name | Scenario |
| --- | --- |
| **env_list.json** | Standard five-env chain: Development ‚Üí Production via PDP stages |
| **env_list_2.json** | Same as `env_list.json`, but with multiple `promote_from` links |
| **env_list_3.json** | Tree-like graph (A1, A2, A3 under C, then E) |
| **env_list_4.json** | Simple two-env chain: Development ‚Üí Production |
| **env_list_5.json** | Reverse order of `env_list_4.json` |
| **env_list_invalid_order1.json** | Broken cycle: tests that sorting terminates without looping |


### Embedding Fixtures in Tests

The fixtures are embedded as raw strings in **utils_test.go**. This allows tests to unmarshal them at runtime and feed them to the sorter.

```go
// internal/bundles/environment/utils_test.go
//go:embed env_sample_data/env_list.json
var envList1 string
//go:embed env_sample_data/env_list_2.json
var envList2 string
//go:embed env_sample_data/env_list_3.json
var envList3 string
//go:embed env_sample_data/env_list_invalid_order1.json
var invalidEnvList string
//go:embed env_sample_data/env_list_4.json
var sharedEnvs string
//go:embed env_sample_data/env_list_5.json
var sharedEnvsReversed string
```

Tests unmarshal these strings into `[]Environment` and invoke `SortEnvironments`. They compare the resulting names against expected linear orders or simply verify that no infinite loop occurs for invalid data .

### Promotion Map and Sorting Logic

Environments declare zero or more predecessors via their `promote_from` arrays. The sorting logic:

1. **Build a promotion map**

Parse each `promote_from` entry into a directed‚Äêgraph map:

```go
   type promotionMap struct {
     fromTo map[common.UniqueIdentifier]map[common.UniqueIdentifier]bool
   }

   func buildPromotionMap(envs []Environment) promotionMap {
     p := promotionMap{fromTo: make(map[UniqueID]map[UniqueID]bool)}
     for _, env := range envs {
       for _, fromStr := range env.PromoteFrom {
         if fromID, err := UUIDFromString(fromStr); err == nil {
           p.SetPromotable(*fromID, env.ID)
         }
       }
     }
     return p
   }
```

1. **Recursive reachability check**

Determine if `a` must come before `b` (or vice-versa) via DFS:

```go
   func isPromotable(pm promotionMap, from, to UniqueID, visited map[UniqueID]bool) bool {
     if pm.fromTo[from][to] {
       return true
     }
     if visited[from] {
       return false
     }
     visited[from] = true
     for mid := range pm.fromTo[from] {
       if isPromotable(pm, mid, to, visited) {
         return true
       }
     }
     return false
   }
```

1. **Comparator and sort**

Use Go‚Äôs `slices.SortFunc` with a comparator that:

- Returns `true` if `a` promotes to `b`.
- Returns `false` if `b` promotes to `a`.
- Otherwise falls back to lexicographical name order.

```go
   func SortEnvironments(envs []Environment) {
     pm := buildPromotionMap(envs)
     slices.SortFunc(envs, func(a, b Environment) bool {
       if isPromotable(pm, a.ID, b.ID, make(map[UniqueID]bool)) {
         return true
       }
       if isPromotable(pm, b.ID, a.ID, make(map[UniqueID]bool)) {
         return false
       }
       return strings.ToLower(a.Name) < strings.ToLower(b.Name)
     })
   }
```

### Validating Ordering and Edge Cases

- **Linear chains** (`env_list.json` / `env_list_2.json`) produce the sequence

`PDP-Development ‚Üí PDP-Staging ‚Üí PDP-Production ‚Üí Development ‚Üí Production`.

- **Tree structures** (`env_list_3.json`) yield an order based on reachability, then name:

`C, A1, A2, A3, E`.

- **Reversed fixtures** (`env_list_4.json` vs. `env_list_5.json`) confirm sort idempotence regardless of input order.
- **Invalid cycles** (`env_list_invalid_order1.json`) ensure the sorter terminates without panicking or looping infinitely; tests simply check for completion when `ignoreResult` is `true`.

Together, these fixtures and tests provide confidence that environment promotion ordering is correct, deterministic, and resilient against malformed input.