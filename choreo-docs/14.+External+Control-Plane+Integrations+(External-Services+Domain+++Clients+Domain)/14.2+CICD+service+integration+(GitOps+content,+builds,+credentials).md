# 14. External Control-Plane Integrations

This section describes how Rudder integrates with external control-plane services via client abstractions. It covers the CICD service responsible for GitOps repository operations, build status tracking, and credential management.

## 14.2 CICD Service Integration

Rudder’s CICD integration wraps HTTP calls to a dedicated GitOps/control-plane service. It provides methods to read and commit GitOps files, query build status, manage auto-builds, and fetch Git credentials. All calls include correlation headers, timeouts, and retry policies for resilience.

### 14.2.1 CICDService Interface

The `CICDService` interface defines all operations Rudder performs against the CICD control plane:

```go
type CICDService interface {
  GetEndpointFile(ctx context.Context, componentId string, commitHash string, fileName string) (*FileContentResponse, error)
  CommitEndpointFilesToGitOpsRepository(ctx context.Context, params CommitFilesParams) (*string, error)
  CommitFileToGitOpsRepository(ctx context.Context, params CommitFilesParams) error
  GetFileOrFolder(ctx context.Context, appId common.UniqueIdentifier, gitHash, path string) ([]byte, error)
  RetrieveRepositoryContent(ctx context.Context, repoType RepositoryType, contentMode ContentMode, appId common.UniqueIdentifier, gitHash, path string, isSourceCommit bool) (*FileContentResponse, *FileListResponse, error)
  GetRepository(ctx context.Context, appId common.UniqueIdentifier, versionId common.UniqueIdentifier) (*GetRepositoryResponse, error)
  UpdateFailureReasonForRun(ctx context.Context, componentId common.UniqueIdentifier, runId int64, failureReason FailureReasonRequest) error
  GetCommitHistory(ctx context.Context, componentId common.UniqueIdentifier, branch string) (*CicdCommitDetails, error)
  GetAutoBuildByComponentIdAndVersionId(ctx context.Context, componentId common.UniqueIdentifier, versionId common.UniqueIdentifier) (*AutoBuildResponse, error)
  GetBuildStatusByDeploymentTrack(ctx context.Context, componentId common.UniqueIdentifier, deploymentTrackId common.UniqueIdentifier) (*BuildStatusResponse, error)
  GetGitCredentialsForComponent(ctx context.Context, componentId common.UniqueIdentifier) (*GitCredentialsResponse, error)
}
```

All methods attach a `common.CorrelationIdHeader` and honor HTTP status codes, timeouts, and retries .

#### Key Constants

| Constant | Meaning |
| --- | --- |
| **RepositoryTypeSource** | Operate on the user’s source repo (value `"app"`) |
| **RepositoryTypeGitOps** | Operate on the Choreo-managed GitOps repo (value `"config"`) |
| **ContentModeFile** | Response will contain file data (`"file"`) |
| **ContentModeDirectory** | Response will contain directory listing (`"dir"`) |
| **AutoBuildNotFound** | Message when no auto-build exists (`"AUTOBUILD NOT EXISTS"`) |


### 14.2.2 cicd_service.go Implementation

The concrete `cicdService` implementation uses an `*http.Client` and the internal `request` helper to perform HTTP calls.

#### GitOps File Operations

- **GetEndpointFile**

Fetch a single endpoint file’s content by commit hash.

```go
  func (svc *cicdService) GetEndpointFile(ctx context.Context, componentId, commitHash, fileName string) (*FileContentResponse, error) {
    url := config.GetConfig().CICDURL +
      "/api/v1/repositories/contents/endpoints/" + componentId +
      "/commits/" + commitHash + "/files/" + fileName

    r := request.HttpRequest{Method: "GET", URL: url}
    r.SetHeader(common.CorrelationIdHeader, common.GetRequestIdFromContext(ctx))
    httpReq, err := request.MakeHttpRequest(r)
    if err != nil {
      return nil, err
    }
    var res struct{ Data cicdFile `json:"data"` }
    _, err = request.New(ctx, svc.httpClient, httpReq, http.StatusOK,
        request.RetryOnStatus(http.StatusInternalServerError),
        request.Timeout(10*time.Second),
        request.LogFnName("cicd.GetEndpointFile")).
      SetResult(&res).Send()

    return &FileContentResponse{
      Success: true,
      Data:    FileItem{Content: res.Data.File.Content},
    }, err
  }
```

- **CommitEndpointFilesToGitOpsRepository**

Commit multiple endpoint files (encoded in request) to the GitOps repo, returning the new commit SHA.

```go
  func (svc *cicdService) CommitEndpointFilesToGitOpsRepository(ctx context.Context, params CommitFilesParams) (*string, error) {
    url := config.GetConfig().CICDURL +
      "/api/v1/repositories/contents/endpoints/" + params.ComponentId

    r := request.HttpRequest{Method: "POST", URL: url}
    r.SetHeader(common.CorrelationIdHeader, common.GetRequestIdFromContext(ctx))
    r.SetJson(params)

    httpReq, err := request.MakeHttpRequest(r)
    if err != nil {
      return nil, err
    }
    var resp struct{ Data cicdCommit `json:"data"` }
    _, err = request.New(ctx, svc.httpClient, httpReq, http.StatusOK,
        request.RetryOnStatus(http.StatusInternalServerError),
        request.Timeout(10*time.Second),
        request.LogFnName("cicd.CommitEndpointFilesToGitOpsRepository")).
      SetResult(&resp).Send()

    return &resp.Data.Sha, err
  }
```

- **CommitFileToGitOpsRepository**

Base64-encodes each file’s content and posts it to a manifest endpoint. Logs and surfaces HTTP errors.

```go
  func (svc *cicdService) CommitFileToGitOpsRepository(ctx context.Context, params CommitFilesParams) error {
    logger := logctx.From(ctx)
    for i := range params.Files {
      params.Files[i].FileContent = base64.StdEncoding.EncodeToString(
        []byte(params.Files[i].FileContent))
    }
    resp, body, _ := gorequest.New().Timeout(time.Minute * 5).
      Post(config.GetConfig().CICDURL + "/api/v1/repositories/contents/manifest").
      Set(common.CorrelationIdHeader, common.GetRequestIdFromContext(ctx)).
      Send(params).End()

    if resp == nil {
      logger.Errorf("cicd:failed to write manifests [resp=nil]")
      return errors.New("cicd:failed to write manifests [resp=nil]")
    }
    if resp.StatusCode >= 300 {
      logger.WithFields(logctx.Fields{
        "appId":  params.ComponentId,
        "status": resp.StatusCode,
        "response": body,
      }).Errorf("cicd:failed to write manifests")
      return fmt.Errorf("cicd: failed to write manifests, received %s", body)
    }
    return nil
  }
```

#### Repository Content Retrieval

- **GetFileOrFolder**

Retrieves raw bytes of a file or directory listing via a dedicated path endpoint.

- **RetrieveRepositoryContent**

Returns either a parsed `FileContentResponse` or `FileListResponse` based on `ContentMode`.

Both methods use `gorequest` for query parameters and handle HTTP status >= 300 as errors .

#### Build and Auto-Build Management

- **GetCommitHistory**
- **GetAutoBuildByComponentIdAndVersionId**
- **GetBuildStatusByDeploymentTrack**
- **UpdateFailureReasonForRun**

Each method constructs a URL under `/api/v1/actions` or `/api/v1/repositories`, logs via `logctx`, unwraps JSON, and surfaces errors with context. Timeouts (up to 5 minutes) and panic-free retry policies ensure robust operations .

#### Git Credentials

- **GetGitCredentialsForComponent**

Fetches username/token pairs for pushing to Git. Returns a `GitCredentialsResponse` or an error if status ≠ 200.

```go
  func (svc *cicdService) GetGitCredentialsForComponent(ctx context.Context, componentId common.UniqueIdentifier) (*GitCredentialsResponse, error) {
    logger := logctx.From(ctx).WithField("componentId", componentId)
    url := fmt.Sprintf("%s/api/v1/choreo/components/%s/git-credentials",
      config.GetConfig().CICDURL, componentId)

    resp, body, errs := gorequest.New().Timeout(time.Minute * 5).
      Get(url).Set(common.CorrelationIdHeader, common.GetRequestIdFromContext(ctx)).End()

    if len(errs) > 0 {
      return nil, fmt.Errorf("error while retrieving git credentials for appId %s: %v", componentId, errs)
    }
    if resp == nil || resp.StatusCode != 200 {
      logger.WithFields(logctx.Fields{"status": resp.StatusCode, "response": body}).
        Infof("cicd:failed to get git credentials")
      return nil, fmt.Errorf("cicd: failed to get git credentials, received %s", body)
    }

    var creds GitCredentialsResponse
    if err := json.Unmarshal([]byte(body), &creds); err != nil {
      logger.WithError(err).WithField("response", body).
        Infof("cicd:failed to unmarshal git credentials response")
      return nil, err
    }
    return &creds, nil
  }
```

### 14.2.3 Failure Handling

- All HTTP calls log errors via the `logctx` package.
- Non-2xx status codes raise formatted errors.
- Timeouts and `RetryOnStatus` guards against transient failures.

### 14.2.4 Mock Implementation (`cicd_service_mock.go`)

The generated `CICDServiceMock` provides function hooks and call tracking for each interface method. It includes per-method `sync.RWMutex` locks and `calls` slices:

```go
type CICDServiceMock struct {
  CommitEndpointFilesToGitOpsRepositoryFunc func(ctx context.Context, params CommitFilesParams) (*string, error)
  CommitFileToGitOpsRepositoryFunc          func(ctx context.Context, params CommitFilesParams) error
  GetAutoBuildByComponentIdAndVersionIdFunc func(ctx context.Context, componentId common.UniqueIdentifier, versionId common.UniqueIdentifier) (*AutoBuildResponse, error)
  // …and all other methods…
  calls struct {
    CommitEndpointFilesToGitOpsRepository []struct{ Ctx context.Context; Params CommitFilesParams }
    // …per-method call info…
  }
  lockCommitEndpointFilesToGitOpsRepository sync.RWMutex
  // …per-method locks…
}
```

Mocks record each invocation for assertions in unit tests .

### 14.2.5 Client Registration

In `external-services/clients/clients.go`, the CICD client is wired into the global client set:

```go
cicdClient := &http.Client{ Timeout: 2 * time.Minute }
clientSet := &clientSet{
  cicdServiceClient: cicd_svc.NewCICDService(cicdClient),
  // …other clients…
}
```

Controllers and services retrieve it via `clientSet.CICDClient()` .

---

This integration ensures Rudder can declaratively manage GitOps repositories, track build pipelines, and automate day-2 operations within Choreo’s data-plane.