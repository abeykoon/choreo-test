# 20.2 Common utilities: UUID types, validation, converters, visibility serialization, YAML conversion

This section covers a suite of shared utilities in `internal/common` that enforce consistent data modeling, error handling, and format conversions across bundles and HTTP handlers.

## 1. UUID utilities üÜî

Unique identifiers are wrapped in a custom `UniqueIdentifier` type. The `Base` model and many bundle structs embed it, ensuring every resource has a UUID primary key.

| Function | Purpose |
| --- | --- |
| **NewUUID()** | Generate a new non-empty UUID. |
| **EmptyUUID()** | Return a zero-value (empty) identifier. |
| **UUIDFromString(str)** | Parse a UUID string into `*UniqueIdentifier`, or error. |
| **UUIDFromStringOrEmpty** | Parse or get `EmptyUUID` on failure. |
| **MustParseUUID(str)** | Parse or panic on invalid string. |


```go
// Generate and scan a new UUID
id := common.NewUUID()
// Parse an incoming path param
uPtr, err := common.UUIDFromString(chi.URLParam(r, "uuid"))
if err != nil {
    handlerutils.RespondWithError(w, r, 400, err)
    return
}
```

These helpers live in `internal/common/helpers.go`  and integrate with GORM‚Äôs `BeforeCreate` hook in `Base` to auto-assign IDs .

## 2. Request error handling ‚ö†Ô∏è

All handler errors are wrapped in a `RequestError`, which carries an HTTP status code, an optional error code, and extra data.

```go
// internal/common/request_error.go
func BadRequestError(err error) RequestError    // 400
func InternalServerError(err error) RequestError// 500
func NotFoundError(err error, code...string) RequestError // 404
func PossibleNotFoundError(err error, msg string, code...string) error
```

Each `RequestError` can be serialized for clients:

```go
payload := r.GetPayload()
// {
//   "message": "not found",
//   "errCode": "NOT_FOUND"
// }
```

Standardizing on this type avoids scattered status codes and messages .

## 3. Data validation ‚úÖ

Struct-level validation uses `valid` tags (powered by govalidator) and a central `common.IsValid` call:

```go
if ok, err := common.IsValid(req); !ok {
    return common.BadRequestError(err)
}
```

This pattern appears in request DTOs and bundle objects, e.g. `EndpointConfigurationV0D2.SetDefaultsAndValidate()` . It ensures all tagged constraints (e.g. `Required`, `Match`) are enforced before processing.

## 4. Converters üîÑ

Generic conversion functions serialize between `interface{}` and Go maps:

```go
func ConvertInterfaceToStringMapInterface(manifest interface{}) (map[string]interface{}, error)
func ConvertInterfaceToStringMapString(manifest interface{}) (map[string]string, error)
func ReplaceRegexFromString(original, regex, replace string) string
func MergeStringMap(input, payload map[string]string) map[string]string
```

They use JSON marshalling under the hood to deep-convert arbitrary structures, enabling consistent manifest handling in generators and metrics code .

## 5. Visibility serialization üëÅÔ∏è

`EndpointVisibilityV2` defines network access levels. The serializer implements:

- **Scan**: read string from DB into enum
- **Value**: write enum to DB as string
- **MarshalJSON**: emit highest visibility for JSON payloads

```go
func (v *EndpointVisibilityV2) Scan(value interface{}) error
func (v EndpointVisibilityV2) Value() (driver.Value, error)
func (v EndpointVisibilityV2) MarshalJSON() ([]byte, error)
```

This guarantees DB ‚Üî Go ‚Üî JSON consistency for visibility fields without repetition across bundles.

## 6. YAML conversion üìÑ

Utilities in `internal/common/yaml_convert.go` support loading and emitting YAML-based descriptors (component.yaml, endpoints.yaml). They wrap libraries like `gopkg.in/yaml.v3` to:

- Read YAML into Go structs
- Merge YAML config blocks
- Serialize Go types back to YAML when needed

This underpins features such as user-provided endpoint parsing and side-car template imports, unifying YAML and JSON workflows in handlers and generators.

---

Together, these **common utilities** enforce uniform UUID handling, input validation, error reporting, data conversion, and serialization across the Rudder service, reducing boilerplate and preventing inconsistencies between bundles and HTTP layers.