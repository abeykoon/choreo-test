## 2.2 OpenAPI/Swagger Contract and Alignment to Handlers

This section describes the OpenAPI/Swagger artifacts in Rudder‚Äôs repository, and how each API definition maps to its corresponding Go handler. Keeping these artifacts in sync with code ensures accurate, discoverable DevOps and Choreo endpoints.

---

### üì¶ OpenAPI/Swagger Artifacts

| Artifact | Format | Purpose | Location |
| --- | --- | --- | --- |
| `openapi.yaml` | OpenAPI 3 | Canonical OpenAPI 3 contract for Choreo Control-Plane and internal Admin APIs | `/openapi.yaml` |
| `docs/swagger.yaml` | Swagger 2 | Legacy Swagger 2 spec used by DevOps Portal clients and documentation | `/docs/swagger.yaml` |
| `docs/swagger.json` | Swagger 2 | JSON-encoded Swagger 2 spec for tooling and client-SDK generation | `/docs/swagger.json` |


> Card: ```card { "title": "Spec Ownership", "content": "Update the OpenAPI/Swagger files whenever you add, change, or remove an endpoint in code." } ```

---

### üìù Keeping Specs Aligned with Code

- **operationId ‚Üî Handler Binding**

Each path operation‚Äôs `operationId` in the spec must match the Go handler‚Äôs function name (minus the `ConfigMap` suffix for DevOps routes).

- **Route Registration**

In `api/api.go`, all `/api/v1` subroutes mount their `routes.*Routes`, ensuring each path in the spec is actually registered  .

- **Validation Middleware**

Query and path parameters declared in the spec (e.g. `organizationId`, `projectId`, `environmentId`, `uuid`) are validated in middleware before hitting handlers .

- **Contract-First Tests**

Rudder‚Äôs CI includes tests that spin up the router and exercise key endpoints, catching drift between spec and implementation .

---

### üîç Example: ConfigMaps CRUD

#### Swagger Definition (`docs/swagger.yaml`)

```yaml
# ConfigMap Management
/api/v1/configmaps:
  get:
    tags:
      - ConfigMaps
    summary: List ConfigMaps
    operationId: listConfigMaps
    parameters:
      - name: organizationId
        in: query
        required: true
        schema:
          type: string
      - name: projectId
        in: query
        required: true
        schema:
          type: string
      - name: environmentId
        in: query
        required: true
        schema:
          type: string
    responses:
      "200":
        description: List of ConfigMaps
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ConfigMapListResponse"
  post:
    tags:
      - ConfigMaps
    summary: Create ConfigMap
    operationId: createConfigMap
    parameters:
      - name: organizationId
        in: query
        required: true
        schema:
          type: string
      - name: projectId
        in: query
        required: true
        schema:
          type: string
      - name: environmentId
        in: query
        required: true
        schema:
          type: string
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ConfigMapRequest"
    responses:
      "201":
        description: ConfigMap created successfully
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ConfigMapResponse"
/api/v1/configmaps/{uuid}:
  get:
    tags:
      - ConfigMaps
    summary: Get ConfigMap by ID
    operationId: getConfigMapById
    parameters:
      - name: uuid
        in: path
        required: true
        schema:
          type: string
          format: uuid
      - name: organizationId
        in: query
        required: true
        schema:
          type: string
      - name: projectId
        in: query
        required: true
        schema:
          type: string
      - name: environmentId
        in: query
        required: true
        schema:
          type: string
    responses:
      "200":
        description: ConfigMap details
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ConfigMapResponse"
      "404":
        description: ConfigMap not found
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ErrorResponse"
  put:
    tags:
      - ConfigMaps
    summary: Update ConfigMap
    operationId: updateConfigMap
    parameters:
      - name: uuid
        in: path
        required: true
        schema:
          type: string
          format: uuid
      - name: organizationId
        in: query
        required: true
        schema:
          type: string
      - name: projectId
        in: query
        required: true
        schema:
          type: string
      - name: environmentId
        in: query
        required: true
        schema:
          type: string
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/ConfigMapRequest"
    responses:
      "200":
        description: ConfigMap updated successfully
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ConfigMapResponse"
  delete:
    tags:
      - ConfigMaps
    summary: Delete ConfigMap
    operationId: deleteConfigMap
    parameters:
      - name: uuid
        in: path
        required: true
        schema:
          type: string
          format: uuid
    responses:
      "204":
        description: ConfigMap deleted successfully
      "404":
        description: ConfigMap not found
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ErrorResponse"
```

#### Route Registration (`api/routes/configmap.go`)

```go
func ConfigMapRoutes(r chi.Router) {
  r.Use(reqvalidators.CreateOrgProjectValidatorMiddleware())
  r.Use(reqvalidators.CreateEnvQueryParamValidatorMiddleware())

  r.Post("/", handlerutils.NewHandler(handlers.ConfigMapCreate, "CREATE_CONFIG_MAP"))
  r.Get("/", handlerutils.NewHandler(handlers.ConfigMapList,   "LIST_CONFIG_MAPS"))
  r.Get("/{uuid}", handlerutils.NewHandler(handlers.ConfigMapGet,    "GET_CONFIG_MAP_BY_ID"))
  r.Put("/{uuid}", handlerutils.NewHandler(handlers.ConfigMapUpdate, "PUT_CONFIG_MAP_BY_ID"))
  r.Delete("/{uuid}", handlerutils.NewHandler(handlers.ConfigMapDelete,"DELETE_CONFIG_MAP_BY_ID"))
}
```

#### Handler Implementations (`api/handlers/configmap.go`)

```go
// Create
func ConfigMapCreate(w http.ResponseWriter, r *http.Request) {
  var body configmap.ConfigMapRequest
  s := handlerutils.NewRequestDataReader()
  s.DecodeRequestBody(w, r, &body)
  if s.HasErrors() { return }

  // Inject validated org/project/env
  orgProj := reqvalidators.GetValidatedOrgProjectFromCtx(r.Context())
  if orgProj.HasValues() {
    body.OrganizationID = orgProj.OrganizationID
    body.ProjectID      = orgProj.ProjectID
  }
  if env := reqvalidators.GetOptionalValidatedEnvFromCtx(r.Context()); env != nil {
    body.EnvironmentID = env.ID
  }

  cfg, err := configmap.ConfigMapCreate(r.Context(), body)
  if err != nil {
    handlerutils.RespondWithError(w, r, http.StatusInternalServerError, err)
    return
  }
  handlerutils.RespondWithJSON(w, r, http.StatusCreated, cfg)
}

// List
func ConfigMapList(w http.ResponseWriter, r *http.Request) {
  var query configmap.ConfigMapRequest
  s := handlerutils.NewRequestDataReader()
  s.DecodeQueryParams(w, r, &query)
  if s.HasErrors() { return }

  if query.EnvironmentID.IsEmpty() && query.ProjectID.IsEmpty() {
    handlerutils.RespondWithError(w, r, 400, fmt.Errorf("environment_id or project_id is required"))
    return
  }

  list, err := configmap.ConfigMapList(query)
  if err != nil {
    handlerutils.RespondWithError(w, r, 404, err)
    return
  }
  handlerutils.RespondWithJSON(w, r, 200, list)
}

// ... Get, Update, Delete follow same pattern ...
```

---

#### Mapping Summary

| Method | Path | operationId | Handler | File |
| --- | --- | --- | --- | --- |
| GET | `/api/v1/configmaps` | `listConfigMaps` | `ConfigMapList` | `api/handlers/configmap.go` |
| POST | `/api/v1/configmaps` | `createConfigMap` | `ConfigMapCreate` | `api/handlers/configmap.go` |
| GET | `/api/v1/configmaps/{uuid}` | `getConfigMapById` | `ConfigMapGet` | `api/handlers/configmap.go` |
| PUT | `/api/v1/configmaps/{uuid}` | `updateConfigMap` | `ConfigMapUpdate` | `api/handlers/configmap.go` |
| DELETE | `/api/v1/configmaps/{uuid}` | `deleteConfigMap` | `ConfigMapDelete` | `api/handlers/configmap.go` |


---

Maintaining this one-to-one correspondence between spec, routes, and handler functions ensures Rudder‚Äôs API surface remains consistent, documented, and easy to navigate for both DevOps and Choreo clients.