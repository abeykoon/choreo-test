## 2.3 Request-Scoped Concerns

This section describes the mechanisms that apply to each incoming HTTP request, ensuring traceability, local caching, consistent responses, and robust upstream integrations.

---

### üîó Correlation ID Propagation

Every request entering Rudder gets a unique **correlation ID**. This ID travels:

- From the client (if provided) or is generated by Chi‚Äôs middleware
- Into the request context
- Into all outgoing service calls
- Back to the client in response headers

| Piece | Value / Function |
| --- | --- |
| Header key | `common.CorrelationIdHeader` |
| Chi setting | `middleware.RequestIDHeader = common.CorrelationIdHeader` |
| Router middleware | `r.Use(middleware.RequestID)` |
| Access in code | `common.GetRequestIdFromContext(r.Context())` |


```go
// In api/api.go, before router setup
middleware.RequestIDHeader = common.CorrelationIdHeader
r.Use(middleware.RequestID)
```

All handlers must set the same header on responses:

```go
w.Header().Set(
  common.CorrelationIdHeader,
  common.GetRequestIdFromContext(r.Context()),
)
RespondwithJSON(w, 200, payload)
```

---

### üóÉÔ∏è Request Cache Injection

Rudder uses a lightweight, in-memory **request cache** to share data across middleware and handlers during a single HTTP invocation.

- Implemented via a small anonymous middleware
- Wraps `r.Context()` with `requestcache.WithRequestCache`
- Available via `requestcache.FromContext(ctx)`

```go
// In api/api.go
r.Route("/", func(r chi.Router) {
  r.Use(func(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
      ctx := requestcache.WithRequestCache(r.Context())
      next.ServeHTTP(w, r.WithContext(ctx))
    })
  })
  // ‚Ä¶ sub-routes ‚Ä¶
})
```

This cache can store per-request data (e.g., validated headers or IDs) so that later components need not re-parse or re-validate.

---

### ‚ö†Ô∏è Error and Response Conventions

Rudder standardizes JSON responses using two patterns:

1. **Success**:
2. Status codes 2xx
3. Body schema:

```json
     { "data": <any> }
```

1. **Error**:
2. Status codes 4xx/5xx
3. Body schema:

```json
     {
       "errors": <string|object|array>,
       "correlation_id": "<same correlation ID>"
     }
```

Handlers use two helpers:

| Function | Description |
| --- | --- |
| `RespondWithError` | Sets status code, writes `{errors, correlation_id}` JSON |
| `RespondwithJSON` | Sets status code, writes `{data}` JSON, injects correlation ID |


```go
// Example in choreo handler
if err != nil {
  RespondWithError(w, r, http.StatusBadRequest, err)
  return
}
RespondwithJSON(w, 200, result)
```

This guarantees clients always receive a **correlation_id** for debugging.

---

### üîÑ Retryable Upstream Calls & Structured Error Mapping

When Rudder proxies or calls external control-plane services, it uses the `external-services/request` package to:

- Propagate the correlation ID
- Retry on transient status codes
- Parse and map errors into Go `error` values

```go
// Example in service-registry client
r := request.HttpRequest{
  Method: "POST",
  URL:    url,
  Query:  map[string]string{ "orgId": orgId },
}
r.SetHeader(common.CorrelationIdHeader, common.GetRequestIdFromContext(ctx))
httpReq, err := request.MakeHttpRequest(r)
// ...
_, err = request.
  New(ctx, svc.httpClient, httpReq, http.StatusCreated,
    request.RetryOnStatus(http.StatusInternalServerError),
    request.Timeout(10*time.Second),
    request.LogFnName("resourceRegistry.UpdateIdl"),
  ).
  Send()
if err != nil {
  return err
}
```

Key patterns:

- **`New(ctx, client, req, wantStatus, opts...)`**: builds a request wrapper
- **`RetryOnStatus(...)`**: marks which HTTP codes should trigger automatic retries
- **`Timeout(...)`**: per-call deadline
- **`LogFnName(...)`**: tags logs with the calling function

All errors bubble up to handlers, where `RespondWithError` maps them to uniform HTTP error responses.