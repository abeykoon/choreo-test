## 1. System Architecture and Service Boundaries

This section describes how Rudder handles incoming HTTP requests from end to end: from the **Chi** router through middleware, into route handlers, deeper into domain bundles, and finally to external control-plane services.

---

### 1.1 Runtime architecture and request flow

At runtime Rudder follows a layered flow:

1. **HTTP Request**
2. **Chi Router**
3. **Middleware Chain**
4. **Context Enrichment**
5. **Route Matching**
6. **Handler Dispatch**
7. **Domain Bundle Execution**
8. **External-Service Client Calls**

```mermaid
flowchart TD
    Client[HTTP Request] --> Router[Chi Router]
    Router --> Middleware[Middleware Chain]
    Middleware --> Enrich[Context Enrichment]
    Enrich --> Matching[Route Matching]
    Matching --> Handler[Handler Function]
    Handler --> Bundle[Domain Bundle]
    Bundle --> External[External Service Client]
    External --> ControlPlane[APIM | CICD | Vault | …]
```

---

#### Chi Router Setup

Rudder’s entrypoint is `LoadAPI()` in `api/api.go`. It wires up CORS, built-in and custom middleware, then defines route groups under `/api/v1`, `/choreo/*`, webhooks and internal admin endpoints.

```go
// LoadAPI routes or return error
func LoadAPI() (*chi.Mux, error) {
    // Correlation header key
    middleware.RequestIDHeader = common.CorrelationIdHeader
    r := chi.NewRouter()

    // CORS
    cors := cors.New(cors.Options{AllowedOrigins: []string{"*"}, …})
    r.Use(cors.Handler)

    // Built-in middleware
    r.Use(middleware.RequestID)
    r.Use(middleware.RealIP)

    // Custom middleware
    r.Use(middlewares.NewStructuredLogger())
    r.Use(middlewares.OperatingMode)
    r.Use(middlewares.RecovererOnPanic)

    // Health check
    r.Route("/healthz", routes.HealthRoutes)

    // Root grouping
    r.Route("/", func(r chi.Router) {
        // Inject a per-request cache into context
        r.Use(func(next http.Handler) http.Handler {
            return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                ctx := requestcache.WithRequestCache(r.Context())
                next.ServeHTTP(w, r.WithContext(ctx))
            })
        })

        // Public API v1
        r.Route("/api/v1/", func(r chi.Router) {
            r.Route("/component", routes.AppRoutes)
            r.Route("/metrics", routes.MetricRoutes)
            r.Route("/configmaps", routes.ConfigMapRoutes)
            r.Route("/secrets", routes.SecretRoutes)
            r.Route("/volume", routes.VolumeRoutes)
            // … choreo domain/project/environments/components/mappings …
        })

        // Webhooks
        r.Route("/choreo/webhooks/v1", choreo_routes.WebhookRoutes)
        r.Route("/webhook/v1/", routes.WebhookRoutes)

        // Internal admin & release-mgt
        r.Route("/internal/admin", choreo_routes.AdminRoutes)
        r.Route("/choreo/autodeploy/v1", choreo_routes.AlertsRoutes)
        r.Route("/choreo/release-mgt/v1", choreo_routes.ReleaseManagementRoutes)
    })

    return r, nil
}
```

---

#### Middleware Chain

– **RequestID** (inserts `X-Request-ID` / correlation ID)

– **RealIP** (captures client IP)

– **StructuredLogger** (JSON request logging)

– **OperatingMode** (detects `X-Operating-Mode: v3`)

– **RecovererOnPanic** (captures panics)

– **RequestCache** (attaches a lightweight per-request cache)

---

#### Route Groups

| Prefix | Purpose | Routes Module |
| --- | --- | --- |
| `/api/v1/component` | App HPA, scaler, endpoints, resiliency … | `api/routes.AppRoutes` |
| `/api/v1/configmaps` | Config Map CRUD | `api/routes.ConfigMapRoutes` |
| `/api/v1/secrets` | Secret CRUD | `api/routes.SecretRoutes` |
| `/choreo/domains` | Domain management | `choreo/routes.DomainRoutes` |
| `/choreo/components` | Component lifecycle (create, deploy, promote …) | `choreo/routes.ComponentRoutes` |
| `/choreo/webhooks/v1` | Incoming webhooks | `choreo/routes.WebhookRoutes` |
| `/internal/admin` | Admin-only endpoints (migration, runbooks …) | `choreo/routes.AdminRoutes` |
| `/choreo/autodeploy/v1` | Automatic undeploy alerts | `choreo/routes.AlertsRoutes` |
| `/choreo/release-mgt/v1` | Release management | `choreo/routes.ReleaseManagementRoutes` |


---

#### Handler Dispatch

Each route group delegates to a set of **handler functions** in:

- `api/handlers/*`
- `choreo/handlers/*`

Handlers are wrapped with `handlerutils.NewHandler(fn, "OPERATION_CODE")`, which:

- Extracts path & query parameters
- Invokes the underlying handler
- Records metrics & traces
- Writes JSON responses or errors

For example, in `api/routes/app.go` the HPA endpoints are wired as:

```go
r.Post("/", handlerutils.NewHandler(handlers.HPACreate, "CREATE_HPA"))
r.Get("/", handlerutils.NewHandler(handlers.HPAList, "LIST_HPA_BY_RELEASE_ID"))
r.Get("/{uuid}", handlerutils.NewHandler(handlers.HPAGet, "GET_HPA_BY_ID"))
r.Put("/{uuid}", handlerutils.NewHandler(handlers.HPAUpdate, "UPDATE_HPA_BY_ID"))
```

---

#### Domain Bundles

Handlers delegate business logic to **bundles** under:

- `internal/bundles/*` (core Rudder logic)
- `choreo/bundles/*`   (Choreo-specific flows)

A bundle encapsulates a resource domain (apps, configmaps, environments, releases, network policies …). Bundles:

- Validate and orchestrate CRUD operations
- Read/write state in MS SQL via GORM
- Generate Kubernetes manifests
- Coordinate cross-domain operations

---

#### External-Service Clients

Bundles call out to external control-plane services through a uniform `clients.Interface`, providing:

- **APIM**
- **CICD**
- **Mizzen**
- **Service Registry**
- **Vault**
- **Alert Service**
- **Cloud Manager**, etc.

These clients are wired in `clients.ClientSet` and injected into bundles. For instance, the Choreo App bundle imports:

```go
import (
    "github.com/wso2-enterprise/choreodp-rudder/external-services/apim"
    "github.com/wso2-enterprise/choreodp-rudder/external-services/cicd"
    "github.com/wso2-enterprise/choreodp-rudder/external-services/vault-service"
    // …
    "github.com/wso2-enterprise/choreodp-rudder/internal/bundles/app"
)
```

---

## Summary

This layered design cleanly separates concerns:

- **Routing & middleware** in `api/api.go`
- **Request validation and HTTP concerns** in handlers
- **Business workflows** in bundles
- **Persistence** via GORM migrations
- **External integration** via dedicated service clients

Together they provide a robust, extensible runtime architecture for managing Choreo data-plane resources.