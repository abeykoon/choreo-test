## 1. System Architecture and Service Boundaries

### 1.3 Operational Modes and Background Tasks

This section describes how Rudder adapts its behavior at runtime via command-line flags and HTTP headers, and how periodic cleanup and undeploy tasks are wired into the service.

---

### OperatingMode Middleware

The **OperatingMode** middleware inspects incoming requests for a special header and tags the request’s context to alter behavior for Choreo V3 clients.

| Header Key | Expected Value | Effect |
| --- | --- | --- |
| **X-Operating-Mode** | **v3** | Marks the context as *Choreo V3* via `common.WithChoreoV3OperatingContext` |


```go
const (
    requestOperatingModeHeaderKey       = "X-Operating-Mode"
    requestOperatingModeHeaderValueV3   = "v3"
)

// OperatingMode sets a flag in the request context if the client is Choreo V3.
func OperatingMode(next http.Handler) http.Handler {
    fn := func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()
        if r.Header.Get(requestOperatingModeHeaderKey) == requestOperatingModeHeaderValueV3 {
            ctx = common.WithChoreoV3OperatingContext(ctx)
        }
        next.ServeHTTP(w, r.WithContext(ctx))
    }
    return http.HandlerFunc(fn)
}
```

The accompanying test verifies both scenarios (header present vs absent):

```go
r := chi.NewRouter()
r.Use(OperatingMode)
// Handler checks common.IsChoreoV3OperatingMode(r.Context())
```

---

### Startup Modes & Scripts

Rudder’s `main.go` defines several boolean flags to select its operating mode at launch. Two key modes are:

- **API Server** (`--server=true`):
- Bootstraps HTTP routes
- Applies middleware (including `OperatingMode`)
- Starts background cleanup/undeploy tasks
- **Cleanup Cron** (`--cleanup-cron=true`):
- Runs a one-off cleanup of old deployment history
- Exits immediately

#### Flags in `main.go`

```go
serverFlag               := flag.Bool("server", true, "Start the http Server")
cleanUpCronFlag          := flag.Bool("cleanup-cron", false, "Start the cleanup cron")
flag.Parse()

if *cleanUpCronFlag {
    // Run database cleanup tasks only
    cleanuptasks.RemoveOldDeployHistoryRecords(ctx)
    return
}

if *serverFlag {
    stopCh := signals.SetupSignalHandler()
    handlers.NewScheduledUndeployTask().Start(stopCh)
    // Start HTTP server...
}
```

#### Startup Scripts

Two convenience scripts wrap these flags:

| Mode | Script | Internal Flags |
| --- | --- | --- |
| Development (dev) | **scripts/startdev.sh** | `--server=true` `--migrate` |
| Cleanup Cron | **scripts/start_cron_mode.sh** | `--cleanup-cron=true` |


> Note: These scripts live under the `scripts/` directory and invoke `main.go` with the corresponding flags.

---

### Scheduled Undeploy Task

When Rudder runs in **API Server** mode, it starts a background ticker that periodically triggers automated undeploy of inactive releases.

#### Wiring in `main.go`

```go
stopCh := signals.SetupSignalHandler()
handlers.NewScheduledUndeployTask().Start(stopCh)
```

#### Task Definition (`choreo/handlers/scheduled_tasks.go`)

```go
func NewScheduledUndeployTask() *scheduledUndeployTask {
    return &scheduledUndeployTask{}
}

func (s *scheduledUndeployTask) Start(stopCh <-chan struct{}) {
    cfg := config.GetConfig().AutoUndeploy
    if cfg.IntervalHours <= 0 || cfg.AfterHours <= 0 {
        logrus.Info("auto-undeploy disabled by config")
        return
    }

    ticker := time.NewTicker(time.Hour * time.Duration(cfg.IntervalHours))
    logrus.Info("starting auto-undeploy task")
    go func() {
        defer logctx.RecoverAndLog()
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        for {
            select {
            case <-stopCh:
                ticker.Stop()
                return
            case <-ticker.C:
                correlationID := fmt.Sprintf("auto-undeploy-%s-%s",
                    time.Now().Format("20060102"), common.NewUUID())
                ctx = context.WithValue(ctx, middleware.RequestIDKey, correlationID)
                _, _ = autoUndeployService.UndeployInactiveReleases(ctx,
                    choreoapp.ReleaseUndeployParams{
                        Hours:          cfg.AfterHours,
                        ExcludedOrgIds: cfg.GetExcludedOrgIds(),
                        Interval:       time.Duration(cfg.BatchIntervalSeconds) * time.Second,
                    }, false)
            }
        }
    }()
}
```

This task uses the **AutoUndeployService** to find and undeploy inactive releases across all organizations, as configured.

---

```mermaid
flowchart LR
    A([Start]) --> B{cleanup-cron?}
    B -- yes --> C[RemoveOldDeployHistoryRecords]
    B -- no  --> D{server?}
    D -- yes --> E[Load API routes]
    E --> F[NewScheduledUndeployTask().Start]
    F --> G[Listen & Serve HTTP]
    D -- no  --> H[Exit]
```

This diagram illustrates Rudder’s entry point decision tree for its operational modes and background task wiring.