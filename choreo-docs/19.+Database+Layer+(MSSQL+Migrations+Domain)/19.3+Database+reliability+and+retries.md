### 19.3 Database reliability and retries

This section describes how Rudder’s MSSQL migrations domain implements **connection pooling**, **retry semantics**, and addresses **known query issues**. It ensures resilient database interactions under transient failures, enforces sensible timeouts for pooled connections and queries, and includes guidance on indexing the `code_server_entries` table for optimal performance.

---

#### 19.3.1 Connection pooling configuration

Rudder applies pool settings on the underlying `*sql.DB` before use:

| Setting | Purpose | Config field |
| --- | --- | --- |
| ConnMaxIdleTime | Maximum idle time for a connection | `DbConfigs.MaxIdleTimeSeconds` |
| ConnMaxLifetime | Maximum lifetime for a connection | `DbConfigs.MaxLifetimeSeconds` |
| MaxOpenConns | Maximum open connections | `DbConfigs.MaxOpenCount` |
| MaxIdleConns | Maximum idle connections | `DbConfigs.MaxIdleCount` |


```go
func (p *MSSQL) SetConfigs(db *sql.DB) {
  if p.MaxIdleTimeSeconds > 0 {
    db.SetConnMaxIdleTime(time.Duration(p.MaxIdleTimeSeconds) * time.Second)
  }
  if p.MaxLifetimeSeconds > 0 {
    db.SetConnMaxLifetime(time.Duration(p.MaxLifetimeSeconds) * time.Second)
  }
  if p.MaxOpenCount > 0 {
    db.SetMaxOpenConns(p.MaxOpenCount)
  }
  if p.MaxIdleCount > 0 {
    db.SetMaxIdleConns(p.MaxIdleCount)
  }
}
```

This hook runs immediately after opening a `sqlserver` connection, ensuring the pool honors configured timeouts and sizes .

---

#### 19.3.2 Retry mechanism implementation

Rudder wraps the standard `*sql.DB` in a custom `connpool` that retries failed operations:

```go
sqlConnPool, _ := sql.Open("sqlserver", dsn)
connPool := connpool.New(sqlConnPool, connpool.RetryParams{
  MaxRetries: 3,
  BackoffFunc: func(failedCount int) time.Duration {
    return time.Duration(failedCount) * 5 * time.Second
  },
})
dialector := sqlserver.New(sqlserver.Config{DSN: dsn, Conn: connPool})
gormDB, err := gorm.Open(dialector, &gorm.Config{ ConnPool: connPool, ... })
```

- **MaxRetries**: up to 3 attempts
- **BackoffFunc**: 5s × attempt number
- Injected into GORM’s dialector for transparent retry on connection errors
- Slow queries are logged at the configured threshold  .

---

#### 19.3.3 Timeout semantics

To balance retry attempts and client deadlines, Rudder’s default configuration is:

| Parameter | Description | Recommended value |
| --- | --- | --- |
| MaxLifetimeSeconds | Pool connection reuse time | ~10 s |
| DriverConnectionTimeout | Dial timeout in go-mssqldb | ~15 s |
| Context timeout | Query-level deadline (enforced by callers) | e.g. 1 min per request |


> ⚙️ Setting `MaxLifetimeSeconds` lower than the connection timeout avoids stale pooled connections . ⚙️ Use context deadlines in GORM operations to bound query time before retry.

---

#### 19.3.4 Retry locations

Two approaches exist for injecting retries:

- **Wrap GORM finisher methods** (`.Find`, `.Take`, etc):
- Pros: handles context timeouts and broken connections.
- Cons: requires patching every GORM chainable method.
- **Wrap ****`*sql.DB`**** methods** (`BeginTx`, `Exec`, etc):
- Pros: single wrapper for all direct SQL operations.
- Cons: context timeouts inside transactions may not propagate as intended .

Rudder opts for the latter, centralizing retry logic in the custom `connpool`.

---

#### 19.3.5 Known MSSQL query issues

GORM’s `.Take` and `.First` on MSSQL add an implicit `ORDER BY id`:

```sql
SELECT * FROM users ORDER BY id OFFSET 0 ROW FETCH NEXT 1 ROWS ONLY
```

This can lead to nondeterministic results when no natural ordering exists. Alternatives:

- Use `SELECT TOP(1) *` via `.Find` on a slice, then inspect the first element.
- Specify a dummy `ORDER BY (select (null))` to suppress default ordering.

```go
var u User
db.Model(&User{}).
  Order("(select (null))").
  Take(&u)
```

Known quirks are documented in `docs/database_query_issues.md` .

---

#### 19.3.6 Performance guidance: `code_server_entries` indexes

Efficient lookups on the `code_server_entries` table are supported by three nonclustered indexes:

| Index name | Columns | Notes |
| --- | --- | --- |
| `idx_code_server_user_org_proj_comp` | `(user_id, organization_id, project_id, component_id)` | Optimizes multi-tenant/user queries |
| `idx_code_server_component_id` | `(component_id)` **INCLUDE** `(code_server_component_id)` | Supports join on BYOI component flow |
| `idx_code_server_project_id` | `(project_id)` | Fast lookups per project |


```sql
CREATE INDEX idx_code_server_user_org_proj_comp
  ON code_server_entries (user_id, organization_id, project_id, component_id);

CREATE INDEX idx_code_server_component_id
  ON code_server_entries (component_id)
  INCLUDE (code_server_component_id);

CREATE INDEX idx_code_server_project_id
  ON code_server_entries (project_id);
```

These indexes match common query patterns in the code-server service, reducing full table scans and improving transactional throughput .

---

```card
{
    "title": "Retry Strategy",
    "content": "Rudder retries up to 3 times with exponential backoff (5s increments) at the SQL pool level."
}
```

By combining tuned pool settings, a robust retry wrapper, clear timeout boundaries, and targeted indexing, Rudder’s database layer maintains high reliability and performance under MSSQL.