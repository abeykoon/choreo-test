## 28. Security, Validation, and Compliance Notes

### 28.1 Request Validators and Domain Invariants

This section explains how Rudder enforces edge-level invariants through HTTP middleware. Each **ReqValidator**:

- Decodes and validates path/query parameters
- Fetches domain objects
- Applies access rules
- Reports errors early
- Stores validated data in `context.Context`

These validators work alongside field-level checks in `internal/common/validation.go` to ensure request integrity and resource compliance.

---

## Validator Chain Flow

```mermaid
flowchart TD
    A[Incoming HTTP Request] --> B[OrgProject Validator]
    B -->|OK| C[Env QueryParam Validator]
    C -->|OK| D[App Validator]
    D -->|OK| E[Release Validator]
    E -->|OK| F[Container Validator]
    F -->|OK| G[HPA Validator]
    G -->|OK| H[EgressPolicy Validator]
    H -->|OK| I[ReleaseManagement Validator]
    I -->|OK| J[Business Logic Handler]
    B -.Error.-> |400/500| Z[RespondWithError]
    C -.Error.-> Z
    D -.Error.-> Z
    E -.Error.-> Z
    F -.Error.-> Z
    G -.Error.-> Z
    H -.Error.-> Z
    I -.Error.-> Z
```

---

## Error Reporting

- **handlerutils.NewRequestDataReader()** reads params and tracks errors.
- On **s.HasErrors()**, the middleware halts and returns immediately.
- Missing or invalid UUIDs trigger `common.BadRequestError` and a 400 status.
- Not-found resources use `common.PossibleNotFoundError` and a 404 or 500 status.
- Access violations return `common.BadRequestError` with 400.

---

## Relation to internal/common/validation.go

The `common` package provides:

- **Custom field validators** (`DomainName`, `NonEmptyUUID`, `ApiVersion`, `ChoreoEnv`)
- **IsValid(obj)** to run Beego validations on structs
- **mergeValidationErrors** to aggregate errors

ReqValidators focus on request-level invariants. They defer to `common` for:

- Field format rules
- UUID presence checks
- Error wrapping

---

## Summary Table of ReqValidators

| File | Context Key | Invariants Enforced |
| --- | --- | --- |
| **project_validator.go** | `validatedOrgProjectInCtxKey` | - `organization_id` & `project_id` must be non-empty UUIDs<br/>- Query decoding errors abort the request |
| **env_query_param_validator.go** | `validatedEnvInCtxKey` | - `environment_id` query param required<br/>- Env must exist and match org/project via `ValidateEnvAccess` |
| **app_validator.go** | `validatedAppInCtxKey` | - `appId` path param required<br/>- App must exist and match org/project via `ValidateAppAccess` |
| **release_validator.go** | `validatedReleaseInCtxKey` | - `appId` & `releaseId` path params required<br/>- Release must exist and match org/project via `ValidateReleaseAccess` |
| **container_validator.go** | `validatedContainerInCtxKey` | - `containerId` path param required<br/>- Container must belong to release via `ValidateContainerAccess` |
| **hpa_validator.go** | `validatedHPAInCtxKey` | - `hpaId` path param required<br/>- HPA must belong to release via `ValidateHPAAccess` |
| **egress_validator.go** | `validatedEgressPolicyInCtxKey` | - `organization_id` required<br/>- Optional `project_id`, `policy_id` validated as UUIDs |
| **release_management_validator.go** | `validatedReleaseManagementReleaseInCtxKey`<br/>`validatedReleaseManagementDeploymentInCtxKey` | - `releaseMgtID` & `deploymentID` path params required<br/>- Resources must exist, then pass `ValidateReleaseAccess` |


---

## Detailed Validator Examples

#### OrgProject Validator

Ensures every request carries valid `organization_id` and `project_id` query parameters.

```go
func CreateOrgProjectValidatorMiddleware() MiddlewareFunc {
  return func(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w, r) {
      query, ok := ValidateOrgProjectQueryParams(w, r)
      if !ok { return }
      ctx := context.WithValue(r.Context(), validatedOrgProjectInCtxKey{}, query)
      next.ServeHTTP(w, r.WithContext(ctx))
    })
  }
}
```

- Uses `handlerutils.NewRequestDataReader().DecodeQueryParams`
- On missing IDs, returns 500 with code `MISSING_ORG_PROJECT_QUERY_PARAMS`
- Stores `common.XPlatformerData` in context

#### Environment QueryParam Validator

Validates `environment_id`, fetches the `Environment` object, and applies access rules.

```go
s.DecodeQueryParams(w, r, &query)
if query.EnvironmentID.IsEmpty() {
  handlerutils.RespondWithError(w,v,400,
    common.BadRequestError(fmt.Errorf("environment_id is required")))
  return
}
env, err := environment.EnvironmentRepository.EnvironmentById(ctx, query.EnvironmentID)
if err != nil {
  handlerutils.RespondWithError(w,r,500,
    common.PossibleNotFoundError(err, fmt.Sprintf("environment [%s] not found", query.EnvironmentID)))
  return
}
if err := environment.ValidateEnvAccess(ctx, orgProject, *env); err != nil {
  handlerutils.RespondWithError(w,r,500,err); return
}
ctx = context.WithValue(ctx, validatedEnvInCtxKey{}, *env)
```

- Enforces existence with a repository lookup
- Applies `ValidateEnvAccess` from `internal/bundles/environment/access_validators.go`

#### App Validator

Checks `appId` path parameter, existence, and access compliance.

```go
appID := s.ReadUUIDPathParam(w,r, appIdParam)
comp, err := app.AppRepository.GetAppById(ctx, appID)
if err != nil {
  RespondWithError(..., PossibleNotFoundError(...)); return
}
if err := app.ValidateAppAccess(ctx, orgProject, *comp); err != nil {
  RespondWithError(..., err); return
}
ctx = context.WithValue(ctx, validatedAppInCtxKey{}, *comp)
```

- Delegates access validation to `internal/bundles/app/access_validations.go`

#### Container Validator

Ensures `containerId` belongs to the validated release.

```go
container, err := app.ContainerRepository.GetById(ctx, containerID)
if err != nil { /* respond not found */ }
if err := app.ValidateContainerAccess(ctx, container, release.ID); err != nil {
  handlerutils.RespondWithError(...); return
}
```

- Uses `ValidateContainerAccess` which checks `container.AppEnvironmentID == release.ID`

#### HPA & EgressPolicy Validators

Follow the same pattern:

- Read UUID path/query parameter
- Fetch via repository
- Apply access validator (e.g., `ValidateHPAAccess`)
- Store in context

#### ReleaseManagement Validators

Handle two resource types:

1. **ReleaseResponse** via `GetReleaseByID`
2. **ReleaseDeploymentResponse** via `GetDeploymentByID`

Both apply `ValidateReleaseAccess` and set distinct context keys.

---

## Domain Invariants Enforced

- Every UUID param must be present and valid.
- Resources must exist in the database.
- **Organization** and **Project** constraints must hold for all bundles.
- **Hierarchical relationships** are enforced:
- App â†’ Project
- Release â†’ App â†’ Project
- Container, HPA, ConfigMaps, HealthChecks â†’ Release
- Middleware fails fast, preventing unauthorized access or malformed data at the API edge.

---

> ðŸ“Œ **Key Takeaway:** Rudderâ€™s ReqValidators form a robust first line of defense. They guard domain invariants before business logic executes, ensuring security, consistency, and compliance.