# 28.2 Security Context Lifecycle and Migrations

This section describes how Rudder persists, migrates, and applies Kubernetes Pod security contexts for Choreo components. It covers database migrations that clear or introduce security‐context storage, the Go model and validation logic, the admin service methods to update contexts, and how least‐privilege settings are injected into generated Pod specs.

## 28.2.1 Security Context Migrations

Rudder uses gormigrate to evolve its database schema for security contexts. Key migrations in the lifecycle:

| Migration ID | Purpose |
| --- | --- |
| **0.0.43** | Reset any existing `containers.security_context` values that were corrupted by an earlier converter. |
| **0.0.80** | Clear all non‐null `security_context` entries so that new values are populated on next deployment YAML. |
| **0.0.180** | Create the `component_security_contexts` table to store individual contexts per component. |
| **0.0.181** | Add `add_capabilities` and `drop_capabilities` JSON columns with default `[]` on the new table. |


Each “clear” migration executes a simple SQL update to null out the old column. The table‐creation and column‐addition migrations run inside transactions to ensure atomicity.

## 28.2.2 Security Context Model and Validation

Rudder defines a request model for updating a component’s security context:

```go
type CompSecurityContextSetRequest struct {
  OrganizationID common.UniqueIdentifier          `json:"organization_id"`
  ComponentID    common.UniqueIdentifier          `json:"component_id"`
  Context        *ComponentSecurityContextRequest `json:"context"`
}
```

`ComponentSecurityContextRequest` holds:

- `ReadOnlyRootFileSystem *bool`
- `AddCapabilities []string`
- `DropCapabilities []string`

Validate logic enforces presence and allowed capability lists from configuration, rejecting disallowed capabilities or empty drop lists when none‐drop is not permitted  .

After validation, `ToComponentSecurityContext()` converts the request into the persisted struct:

```go
func (c *CompSecurityContextSetRequest) ToComponentSecurityContext() *ComponentSecurityContext {
  if c.Context.DropCapabilities == nil {
    c.Context.DropCapabilities = []string{}
  }
  return &ComponentSecurityContext{
    ComponentID:            c.ComponentID,
    ReadOnlyRootFileSystem: *c.Context.ReadOnlyRootFileSystem,
    AddCapabilities:        c.Context.AddCapabilities,
    DropCapabilities:       c.Context.DropCapabilities,
  }
}
```

## 28.2.3 Admin Service Methods

The admin bundle exposes two methods to manage security contexts:

### SetComponentSecurityContext

```go
func (s *Service) SetComponentSecurityContext(
  ctx context.Context,
  req *app.CompSecurityContextSetRequest,
) (*app.CompSecurityContextGetResponse, error) { … }
```

- Validates the request and ensures the component belongs to the organization.
- Upserts the context via the repository.
- Fetches all related releases and calls `SyncReleaseManifests` to redeploy YAMLs with updated contexts .

### GetComponentSecurityContext

```go
func (s *Service) GetComponentSecurityContext(
  ctx context.Context,
  componentID common.UniqueIdentifier,
) (*app.CompSecurityContextGetResponse, error) { … }
```

- Loads the component, then retrieves its stored security context from the repository .

## 28.2.4 Applying Least‐Privilege to Pod Specs

When Rudder generates Kubernetes manifests, it injects the stored security context into each `PodSpec`. In the deployer:

```go
func (s *deployer) SetSecurityContext(
  ctx context.Context,
  podSpec *generator.PodSpec,
  componentId common.UniqueIdentifier,
  env environment.Environment,
) error {
  securityContext, err := ComponentSecurityContextRepository.GetByComponentID(ctx, componentId)
  if err != nil {
    if db.IsDBRecordNotFoundError(err) {
      return nil
    }
    return fmt.Errorf("deployer.SetSecurityContext: %w", err)
  }
  // Skip for non‐PDP environments
  if !env.IsPdp() {
    logctx.From(ctx).Info("SetSecurityContext: security context is not applied for non‐PDP environments")
  }

  // Build capabilities filters, respecting allowed lists
  capabilities := generator.Capabilities{}
  for _, c := range securityContext.AddCapabilities {
    capabilities.Add = append(capabilities.Add, generator.Capability(c))
  }
  for _, c := range securityContext.DropCapabilities {
    capabilities.Drop = append(capabilities.Drop, generator.Capability(c))
  }

  // Enforce drop list presence if none‐drop is disallowed
  if len(capabilities.Drop) == 0 && !config.GetConfig().DataPlane.PDPCapabilitiesDropNoneAllowed {
    return fmt.Errorf("deployer.SetSecurityContext: drop_capabilities is empty")
  }

  // Apply to all containers in the Pod
  for i := range podSpec.Containers {
    podSpec.Containers[i].SecurityContext.ReadOnlyRootFilesystem = common.BoolPointer(securityContext.ReadOnlyRootFileSystem)
    podSpec.Containers[i].SecurityContext.Capabilities = &capabilities
  }
  return nil
}
```

This ensures each container runs:

- With `readOnlyRootFilesystem` as configured.
- Only the explicit capabilities added.
- All others dropped, satisfying least‐privilege principles .

By resetting legacy values, persisting structured contexts, validating at both API‐ and manifest‐generation time, and applying minimal permissions, Rudder enforces a consistent, least-privilege policy across deployments.