# 30. Testing Strategy and Test Utilities

This section describes the core test harness utilities and helpers that underpin the API and domain-level tests. These utilities simplify common tasks such as creating request bodies, reading and comparing JSON, managing context, and defining comparison options for domain objects. They enable consistent, concise tests across the codebase.

## 30.1 Test Harness Utilities for HTTP and Domain Objects üõ†Ô∏è

Below is an overview of the primary packages and files in the `internal/testutils` and `internal/test` domains. Each provides functions to streamline HTTP testing, context handling, JSON comparison, and object equality checks.

| Package & File | Purpose |
| --- | --- |
| **internal/testutils/ctx.go** | Create a request context with a fixed request-ID, used by controller tests. |
| **internal/testutils/req_utils.go** | Build request bodies, send HTTP requests to a `chi.Mux`, and read/parses response payloads. |
| **internal/testutils/jsondiff.go** | Generate unified diffs between expected and actual JSON values, and sort JSON arrays by key. |
| **internal/testutils/cmpopts.go** | Predefined `cmp.Options` for ignoring IDs, timestamps, metadata, and comparing UUIDs and times. |
| **internal/test/utils.go** | Domain-specific helpers for asserting UUID validity, request errors, and creating a test context. |


### Context Utilities

The `NewTestCtx` function injects a deterministic request ID into a background context. This allows handlers to log and propagate the same ID across mock requests.

```go
// internal/testutils/ctx.go
func NewTestCtx(requestId string) context.Context {
    return context.WithValue(
        context.Background(),
        middleware.RequestIDKey,
        requestId,
    )
}
```

Use in tests to initialize controller context:

```go
ctx := testutils.NewTestCtx("health-test")  // 
```

### HTTP Request Helpers

`req_utils.go` defines utilities to create JSON request bodies, send them through a `chi.Mux`, and read generic or string responses.

```go
// internal/testutils/req_utils.go
func CreateReqBody(t *testing.T, payload map[string]any) *bytes.Buffer
func SendRequest(t *testing.T, router *chi.Mux, req *http.Request) *httptest.ResponseRecorder
func ReadResBody[T any](t *testing.T, res *httptest.ResponseRecorder) T
func ValidateErrorResponse(t *testing.T, res *httptest.ResponseRecorder, status int, errorCode, msg string)
```

Example usage in API tests:

```go
reqBody := testutils.CreateReqBody(t, map[string]any{"name":"app"})    
req := httptest.NewRequest(http.MethodPost, "/api/v1/apps", reqBody)
res := testutils.SendRequest(t, router, req)
testutils.ValidateErrorResponse(t, res, http.StatusBadRequest, "MISSING_NAME", "name is required")  // 
```

### JSON Difference and Sorting

`jsondiff.go` offers functions to compute diffs between two JSON structures, highlighting additions, removals, and changes. It also allows sorting of array items at a given JSON path by a key.

```go
// internal/testutils/jsondiff.go
func JSONDiff(want, got any) string
func JSONDiffStr(want string, got any) string
func SortItemsOnJSONPathByKey(t *testing.T, m any, jsonPath, sortBy string) map[string]any
```

Within tests, you can assert that two JSON payloads match exactly:

```go
diff := testutils.JSONDiff(expectedObj, actualObj)
assert.Empty(t, diff, "payload mismatch:\n%s", diff)  //  
```

### Comparison Options for Domain Objects

`cmpopts.go` defines reusable `cmp.Option`s to ignore common fields like IDs, timestamps, and internal metadata when comparing domain objects with `cmp.Diff`.

```go
// internal/testutils/cmpopts.go
var (
  IgnoreId         = cmpopts.IgnoreFields(common.Base{}, "ID")
  IgnoreTimestamps = cmpopts.IgnoreFields(common.Base{}, "CreatedAt", "UpdatedAt")
  CommonOpts       = []cmp.Option{IgnoreId, IgnoreMutex, IgnoreMetadata, IgnoreTimestamps, cmp.Comparer(compareTimestamps)}
)
func CompareUUIDString(in common.UniqueIdentifier) string { return in.String() }
```

Use in tests to compare two `AppEnvironment` values while ignoring auto-generated fields:

```go
if diff := cmp.Diff(wantEnv, gotEnv, testutils.CommonOpts...); diff != "" {
    t.Fatalf("environment mismatch: %s", diff)
}  // 
```

### Domain-Level Assertions

`internal/test/utils.go` provides helpers to assert specific domain invariants, such as validating UUIDs or expected error codes.

```go
// internal/test/utils.go
func ExpectValidUUID(t *testing.T, id common.UniqueIdentifier, fieldName string)
func ExpectRequestError(t *testing.T, err error, status int, code string)
func NewTestCtx(requestId string) context.Context
```

These reduce boilerplate when asserting domain constraints:

```go
testutils.ExpectValidUUID(t, createdApp.ID, "App.ID")  
testutils.ExpectRequestError(t, err, 404, "APP_NOT_FOUND")  // 
```

## Patterns in `api/tests/*`

Across the `api/tests` directory, tests consistently follow these patterns:

1. **Database State Setup**
2. Create domain objects via bundle test-object functions (e.g. `environment.CreateEnvTestObject`, `app.CreateAppTestObject`)
3. Persist them using `environment.SaveEnv`, `app.SaveAppObjects`, `app.SaveReleaseObjects` before issuing API calls.

1. **Mock External Services**
2. Start a mock HTTP server for external dependencies (Mizzen, Vault, etc.) using `requestutils.NewTestServerWithURL`
3. Inject service mocks into controllers before routing requests.

1. **HTTP Request Execution**
2. Build request bodies with `testutils.CreateReqBody`.
3. Send requests through `api.LoadAPI()` router with `testutils.SendRequest`.
4. Attach organization/project query params or headers as needed.

1. **Response Validation**
2. Assert HTTP status codes directly on the recorder.
3. Unmarshal JSON into typed structs via `testutils.ReadResBody[T]`.
4. Use `cmp.Diff` with `testutils.CommonOpts` or `testutils.JSONDiff` to compare response payloads against expected objects.
5. For error cases, call `testutils.ValidateErrorResponse` to ensure status, error code, and message match.

This harness of utilities and patterns ensures tests remain concise, focused on behavior, and free of repetitive setup or boilerplate.