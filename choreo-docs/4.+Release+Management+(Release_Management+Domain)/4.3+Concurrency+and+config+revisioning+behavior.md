## 4.3 Concurrency and Config Revisioning Behavior

This section discusses how Rudder ensures **unique sequencing** of configuration revisions and deployment attempts under concurrent operations. It covers the database constraints, transactional retry patterns, config-revision logic in the controller, and the tests that validate concurrency behavior.

---

### 4.3.1 ðŸ”’ Database Uniqueness Constraints

Rudderâ€™s Day-2 operations rely on SQL Server enforcing uniqueness of each deployment record. Migration **0.0.213** defines:

| Constraint Name | Columns | Purpose |
| --- | --- | --- |
| unique_release_mgt_id_environment_id_config_revision_attempt | release_mgt_id, environment_id, config_revision, attempt | Ensure each (release, env, revision, attempt) tuple is unique. |


This rule prevents two concurrent writes from inserting the same `(config_revision, attempt)` pair for a given release and environment .

---

### 4.3.2 ðŸ”„ Transactional Retry & Idempotency

All deployment and config-update operations run inside a retry loop that catches database races, deadlocks, and timeouts. The helper `executeInTransactionWithRetry`:

```go
func (s *releaseMgmtController) executeInTransactionWithRetry(
    ctx context.Context,
    operationName string,
    maxRetries int,
    fn func(txCtx context.Context) error,
) error {
    var lastErr error
    for attempt := 0; attempt < maxRetries; attempt++ {
        err := db.DB(ctx).Transaction(func(tx *gorm.DB) error {
            return fn(db.CtxWithTx(ctx, tx))
        })
        if err == nil {
            return nil
        }
        lastErr = err
        logFields := logrus.Fields{"operation": operationName, "attempt": attempt + 1}
        switch {
        case IsUniqueConstraintViolation(err):
            logctx.From(ctx).WithFields(logFields).Warn("unique constraint, retrying")
        case IsDeadlockError(err):
            logctx.From(ctx).WithFields(logFields).Warn("deadlock, retrying")
        case IsTimeoutError(err):
            logctx.From(ctx).WithFields(logFields).Warn("timeout, retrying")
        default:
            return err
        }
        // backoff + jitter omitted for brevity
    }
    return fmt.Errorf("failed %s after %d attempts: %w", operationName, maxRetries, lastErr)
}
```

This ensures **idempotent** retries on transient conflicts .

---

### 4.3.3 âš™ï¸ Config Revision Computation

When `UpdateComponentDeploymentConfig` is invoked, the controller:

1. **Load current state**
2. Fetch existing deployment via `GetDeployment`
3. Load latest config via `GetLatestDeploymentWithConfigsByReleaseMgtId`

1. **Detect change**
2. Compare `existingConfig` vs. `newConfig` using `HasConfigurationChanged`

1. **Choose revision & attempt**
2. If **changed**:
3. `config_revision = GetNextConfigRevision(...)`
4. `attempt = 1`
5. If **unchanged**:
6. `config_revision = GetLatestConfigRevision(...)`
7. `attempt = GetLastAttemptNumber(..., config_revision) + 1`

1. **Persist new deployment record**
2. Create `ReleaseDeployment{ConfigRevision, Attempt, â€¦}`

```go
if hasChanged {
  configRevision, _ = repo.GetNextConfigRevision(txCtx, releaseID, envID)
  attemptNumber = 1
} else {
  configRevision, _ = repo.GetLatestConfigRevision(txCtx, releaseID, envID)
  lastAttempt, _ := repo.GetLastAttemptNumber(txCtx, releaseID, envID, configRevision)
  attemptNumber = lastAttempt + 1
}
deployment := ReleaseDeployment{
  ReleaseMgtID:   releaseID,
  EnvironmentID:  envID,
  ConfigRevision: configRevision,
  Attempt:        attemptNumber,
  â€¦,
}
repo.CreateDeployment(txCtx, &deployment)
```

This flow guarantees **monotonic** revision numbers and linear attempts per revision .

---

### 4.3.4 ðŸ§ª Concurrency Tests

#### 4.3.4.1 Config Revision Generation

`TestConcurrentConfigRevisionGeneration` spins up 10 goroutines, each calling `UpdateComponentDeploymentConfig` on the same initial deployment. It asserts:

- At least half of the updates succeed
- All returned `ConfigRevision` values are â‰¥ 2
- At least 2 distinct revision numbers appear

```go
firstDeployment, _ := service.DeployRelease(...)
for i := 0; i < 10; i++ {
  go func(idx int) {
    update := ComponentDeploymentConfigRequest{ConfigMappingRevision: idx+2, â€¦}
    _ = service.UpdateComponentDeploymentConfig(ctx, firstDeployment.ID, update)
    latest := findLatestDeployment(...)
    results[idx] = latest.ConfigRevision
  }(i)
}
â€¦ assert.Len(uniqueRevisions, â‰¥ 2)
```

This validates concurrent revision allocation under load .

#### 4.3.4.2 Mixed Release & Config Operations

The mixed-operations test alternates between **creating releases** and **generating config revisions** to ensure neither blocks the other. It verifies both operation types reach expected success counts .

---

### 4.3.5 ðŸ“ Config Revisioning Logic Tests

`TestConfigRevisionLogic` in `release_config_revisioning_test.go` covers:

| Scenario | Expected Config Revision | Expected Attempt |
| --- | --- | --- |
| **First Deployment** | 1 | 1 |
| **Config Change** | increment (â†’ 2) | reset to 1 |
| **Redeploy Same Config** | same (2) | increment (â†’ 2) |
| **Multiple Component Changes** | increment once (â†’ 3) | reset to 1 |


```go
// Redeploy same config
redeploy, _ := service.RedeployRelease(ctx, latest.ID, â€¦)
assert.Equal(latest.Attempt+1, redeploy.Attempt)
assert.Equal(latest.ConfigRevision, redeploy.ConfigRevision)
```

This confirms **idempotency** for redeployment and **revision bump** only when configurations differ .

---

### 4.3.6 ðŸ”— Repository Support & Relationships

Key repository methods enable revision tracking:

- `GetLatestConfigRevision` / `GetNextConfigRevision`
- `GetLastAttemptNumber`
- `HasConfigurationChanged`

```go
func (r *releaseRepository) GetNextConfigRevision(...) (int, error) {
  rev, _ := r.GetLatestConfigRevision(...)
  return rev + 1, nil
}
```

These form the backbone of the controllerâ€™s **revisioning behavior** .

---

Through these constraints, patterns, and tests, Rudderâ€™s release-management domain guarantees safe, deterministic **config revisioning** and **deployment attempts** under heavy concurrency.