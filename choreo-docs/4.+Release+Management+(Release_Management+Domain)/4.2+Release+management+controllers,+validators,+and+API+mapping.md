# 4.2 Release Management Controllers, Validators, and API Mapping

This section covers the internal **Release Management** domain in Rudder, focusing on how HTTP requests for release operations are validated, routed, handled by the controller layer, and mapped to API-level responses. Weâ€™ll explore:

- The **ReleaseManagementController** interface and its implementation
- The **API mapping** layer that converts GORM models into response structs
- The **request validators** that enforce path-parameter correctness and access control
- The **handler** and **routing** layers that wire everything together

---

## 4.2.1 Controllers

The `ReleaseManagementController` defines the core business-logic operations for releases and deployments. It lives in

`internal/bundles/release_management/release_management_controller.go`.

**Key responsibilities**

- Persisting and retrieving release definitions
- Generating release numbers and metadata
- Managing deployments: create, list, redeploy, delete
- Recording and querying deployment activities
- Handling APIM base revisions

### Interface Overview

| Method | Purpose |
| --- | --- |
| CreateRelease(ctx, req) â†’ *ReleaseResponse | Create a new draft release |
| GetReleaseByID(ctx, id) â†’ *ReleaseResponse | Fetch detailed release info |
| ListReleases(ctx, req) â†’ []ReleaseResponse | List releases with pagination/filtering |
| UpdateRelease(ctx, id, req, updatedBy) â†’ *ReleaseResponse | Update release fields (description, component, metadata) |
| DeleteRelease(ctx, id, deletedBy) â†’ error | Delete a release if no active deployments exist |
| DeployRelease(ctx, id, req) â†’ *ReleaseDeploymentResponse | Trigger a new deployment |
| GetDeploymentByID(ctx, id) â†’ *ReleaseDeploymentResponse | Fetch a single deployment |
| ListDeploymentsByReleaseMgtID(ctx, id, off, lim) â†’ []ReleaseDeploymentResponse | List deployments for a release |
| ListDeploymentsByComponentAndDeploymentTrack(ctx, envID, compID, trackID, off, lim) â†’ []ReleaseDeploymentResponse | Filtered listing |
| RedeployRelease(ctx, deployID, redeployedBy, comment) â†’ *ReleaseDeploymentResponse | Create a redeployment |
| DeleteDeployment(ctx, deployID, deletedBy) â†’ error | Remove a deployment record |
| UpdateDeploymentStatus(ctx, deployID, status) â†’ error | Change deployment status (e.g. Pending â†’ Success) |
| UpdateComponentDeploymentConfig(ctx, deployID, cfg) â†’ error | Update per-deployment component config |
| GetComponentDeploymentConfigs(ctx, deployID) â†’ *ComponentDeploymentConfigResponse | Fetch component config |
| GetReleaseActivityLogs(ctx, id, off, lim) â†’ []ReleaseActivityLogResponse | Audit trail for a release |
| GetDeploymentActivityLogs(ctx, id, off, lim) â†’ []ReleaseActivityLogResponse | Audit trail for a deployment |


ğŸ”„ The concrete implementation, `releaseMgmtController`, uses GORM transactions with retry logic for create/update operations and logs every major step with `logctx` .

```go
func NewReleaseMgmtController() ReleaseManagementController {
  return &releaseMgmtController{ repository: &ReleaseRepository }
}
```

---

## 4.2.2 API Mapping

The APIâ€mapping layer transforms internal GORM models into clean, version-stable response structs. It resides in

`internal/bundles/release_management/api_mapper.go`.

### Core Mapping Functions

| Function | Input | Output |
| --- | --- | --- |
| `ToReleaseResponse(dbRelease, dbRevisions)` | `*Release`, `[]ReleaseApimBaseRevision` | `*ReleaseResponse` |
| `ToReleaseResponseList(dbReleases)` | `[]Release` | `[]ReleaseResponse` |
| `ToReleaseDeploymentResponse(dbDeployment, dbRevisions)` | `*ReleaseDeployment`, `[]ReleaseApimBaseRevision` | `*ReleaseDeploymentResponse` |
| `ToReleaseDeploymentResponseList(dbDeployments, apimMap)` | `[]ReleaseDeployment`, `map[string][]ReleaseApimBaseRevision` | `[]ReleaseDeploymentResponse` |
| `ToComponentDeploymentConfigResponse(dbConfig)` | `*ReleaseDeployment` | `*ComponentDeploymentConfigResponse` |
| `ToReleaseDeploymentLogResponse(dbLog)` | `*ReleaseActivityLog` | `*ReleaseActivityLogResponse` |


**Example**: converting a `Release` model to its API representation

```go
response := &ReleaseResponse{
  ID:                dbRelease.ID,
  OrganizationID:    dbRelease.OrganizationID,
  Name:              dbRelease.Name,
  Status:            dbRelease.Status,
  CreatedBy:         dbRelease.CreatedBy,
  ReleaseDate:       dbRelease.ReleaseDate,
  ReleaseNumber:     dbRelease.ReleaseNumber,
  ComponentID:       dbRelease.ComponentID,
  DeploymentTrackID: dbRelease.DeploymentTrackID,
  CommitHash:        dbRelease.CommitHash,
  ImageTag:          dbRelease.ImageTag,
  CreatedAt:         dbRelease.CreatedAt,
  UpdatedAt:         dbRelease.UpdatedAt,
  APIMBaseRevisions: ToReleaseApimBaseRevisionResponseList(dbRevisions),
}
// Metadata JSON string â†’ Go map
if metadata, err := dbRelease.GetMetadata(); err == nil {
  response.Metadata = metadata
} else {
  logrus.WithError(err).Warn("Failed to parse release metadata")
}
```

ğŸ“¦ All mapping functions ensure nil safety and log any JSON parsing issues .

---

## 4.2.3 Request Validators

Incoming HTTP requests hit two path-param validators before reaching the handler:

```plaintext
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  CreateOrgProjectValidatorMiddleware   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CreateReleaseManagementValidatorMiddleware       â”‚
â”‚ â†’ ValidateReleaseManagementPathParam             â”‚
â”‚   â€¢ parse â€œreleaseMgtIDâ€                          â”‚
â”‚   â€¢ controller.GetReleaseByID(...)                â”‚
â”‚   â€¢ common.PossibleNotFoundError / BadRequestErrorâ”‚
â”‚   â€¢ set `ctx` key for ReleaseResponse             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CreateDeploymentValidatorMiddleware             â”‚
â”‚ â†’ ValidateDeploymentPathParam                     â”‚
â”‚   â€¢ parse â€œreleaseDeploymentIDâ€                   â”‚
â”‚   â€¢ controller.GetDeploymentByID(...)             â”‚
â”‚   â€¢ fetch associated release for access check     â”‚
â”‚   â€¢ set `ctx` key for ReleaseDeploymentResponse   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Middleware functions** wrap `http.Handler` and inject validated objects into the request `Context`.
- **Path-param validation** uses `handlerutils.NewRequestDataReader()` to read UUIDs and short-circuit on errors.
- **Access checks** compare organization/project from context (`common.XPlatformerData`) against the resourceâ€™s fields.
- **Error standardization** is done via `common.PossibleNotFoundError` and `common.BadRequestError`, then returned through `handlerutils.RespondWithError` .

---

## 4.2.4 Routes & Handlers

All release management routes live in `choreo/routes/release_management.go` and use the Chi router:

```go
r.Use(reqvalidators.CreateOrgProjectValidatorMiddleware())

// Collection
r.Post("/releases",    NewHandler(handlers.CreateRelease,    "CREATE_RELEASE"))
r.Get ("/releases",    NewHandler(handlers.ListReleases,     "LIST_RELEASES"))

// Resource
r.Route("/releases/{releaseMgtID}", ReleaseByIDRoutes)

// Component-environment deployment listing
r.Get("/components/{componentID}/deployment-tracks/{deploymentTrackID}/environments/{environmentID}/deployments",
  NewHandler(handlers.ListDeploymentsByComponentAndVersion, "LIST_DEPLOYMENTS_BY_ENVIRONMENT"))
```

Inside `ReleaseByIDRoutes`:

```go
r.Use(reqvalidators.CreateReleaseManagementValidatorMiddleware("releaseMgtID"))
r.Get   ("/",                        NewHandler(handlers.GetRelease,                      "GET_RELEASE"))
r.Put   ("/",                        NewHandler(handlers.UpdateRelease,                   "UPDATE_RELEASE"))
r.Delete("/",                        NewHandler(handlers.DeleteRelease,                   "DELETE_RELEASE"))
r.Post  ("/apim-base-revisions",     NewHandler(handlers.CreateReleaseApimBaseRevisions,  "CREATE_RELEASE_APIM_BASE_REVISIONS"))
r.Get   ("/apim-base-revisions",     NewHandler(handlers.GetReleaseApimBaseRevisions,     "GET_RELEASE_APIM_BASE_REVISIONS"))
r.Route ("/deployments",             ReleaseDeploymentRoutes)
```

And `ReleaseDeploymentRoutes` include:

```go
r.Post   ("/",                             NewHandler(handlers.DeployRelease,              "CREATE_DEPLOYMENT"))
r.Get    ("/",                             NewHandler(handlers.ListDeployments,            "LIST_DEPLOYMENTS"))
r.Route  ("/{releaseDeploymentID}",        DeploymentByIDRoutes)
```

Where `DeploymentByIDRoutes` wires:

```go
r.Use   (reqvalidators.CreateDeploymentValidatorMiddleware("releaseDeploymentID"))
r.Get   ("/", NewHandler(handlers.GetDeployment,           "GET_DEPLOYMENT"))
r.Delete("/", NewHandler(handlers.DeleteDeployment,        "DELETE_DEPLOYMENT"))
r.Post  ("/redeploy", NewHandler(handlers.RedeployDeployment,"REDEPLOY_DEPLOYMENT"))
r.Put   ("/status",   NewHandler(handlers.UpdateDeploymentStatus,"UPDATE_DEPLOYMENT_STATUS"))
r.Route ("/configs", NewHandler(handlers.GetDeploymentComponentConfigs,  "GET_DEPLOYMENT_CONFIGS"))
           .Put("/",    NewHandler(handlers.UpdateDeploymentConfig,          "UPDATE_DEPLOYMENT_CONFIG"))
r.Route ("/activity", NewHandler(handlers.GetDeploymentActivityLogs,      "GET_DEPLOYMENT_ACTIVITY"))
```

### Handler Pattern

Each handler in `choreo/handlers/release_management_handlers.go` follows:

1. **Decode & validate** request body or path param
2. **Retrieve** validated org/project from context
3. **Additional field checks** (e.g. non-empty `CreatedBy`, `ComponentID`)
4. **Invoke controller**
5. **Error handling** via `RespondWithError`
6. **Success** via `RespondWithJSON`

Example: **CreateRelease**

```go
s := handlerutils.NewRequestDataReader()
s.DecodeRequestBody(w, r, &req)
if s.HasErrors() { return }
// inject org/project
orgProject := reqvalidators.GetValidatedOrgProjectFromCtx(ctx)
req.OrganizationID = orgProject.OrganizationID
req.ProjectID      = orgProject.ProjectID
// required-field checks
if req.CreatedBy == ""        { RespondWithError(...); return }
if req.ComponentID.IsEmpty()  { RespondWithError(...); return }
if req.DeploymentTrackID == ""{ RespondWithError(...); return }
// business logic
createdRelease, err := releaseMgtController.CreateRelease(ctx, req)
if err != nil { RespondWithError(...); return }
// respond
RespondWithJSON(w, http.StatusCreated, createdRelease)
```

ğŸ‘©â€ğŸ’» The handlers leverage the controller interface and mapping layer, keeping HTTP concerns separate from business logic .

---

This layered designâ€”**validators â†’ handlers â†’ controllers â†’ repository â†’ mappers**â€”ensures clear separation of concerns, consistent error handling, and straightforward extension for future features.