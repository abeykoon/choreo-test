## 11.3 Auth key service and AuthZ gRPC integration üîê

This section covers how the **Choreo control plane** enforces authorization for key-set operations by integrating with the **AuthZ Service** over gRPC. It details the service definition, client stub setup, in-request authorization checks, and mock support for testing.

### 11.3.1 AuthZ gRPC API Definition

The AuthZ Service exposes a single RPC to verify permissions for a given action in context.

```proto
syntax = "proto3";
package authz.choreo.apis;

service ChoreoAuthorization {
  // Checks if the requester has the required permission in the given context.
  rpc IsActionAllowed(IsActionAllowedRequest) returns (IsActionAllowedResponse);
}

message IsActionAllowedRequest {
  string required_permission = 1;      // e.g. "urn:choreocontrolplane:configmanagement:config_manage"
  ActionContext action_context = 2;    // Logical context for the check
}

message IsActionAllowedResponse {
  bool is_allowed = 1;                 // true if permitted
}

message ActionContext {
  string org_uuid = 1;
  string environment_uuid = 2;
  string project_uuid = 3;
  string component_uuid = 4;
  string deployment_track_uuid = 5;
}
```

- **ChoreoAuthorization**: service name
- **IsActionAllowedRequest**: carries the permission string and context
- **IsActionAllowedResponse**: boolean result flag
- **ActionContext**: identifies the org, env, project, component, and track

### 11.3.2 Client Stub and Initialization

A gRPC client is generated from the `.proto` and wired into the application‚Äôs client set.

```go
// Dial the AuthZ service and wrap in a strongly-typed client:
authzConn, err := grpc.Dial(
  config.GetConfig().AuthzServiceURL,
  grpc.WithTransportCredentials(insecure.NewCredentials()),
)
if err != nil {
  return nil, fmt.Errorf("authz service: %w", err)
}
c.authzService = authz_service.NewChoreoAuthorizationClient(authzConn)
```

- The `clients.Interface` exposes this via

```go
  AuthzServiceClient() authz_service.ChoreoAuthorizationClient
```

- Initialization lives alongside other external-service clients

### 11.3.3 Authorization Check in Key-Set Handlers

Before performing any key-set operation (create, generate, regenerate, delete), handlers invoke `IsActionAllowedOnKeySetResource`. This helper:

- Extracts the `x-jwt-assertion` from the incoming HTTP request
- Attaches it as metadata to the gRPC context
- Calls `IsActionAllowed` on the AuthZ client
- Interprets errors and `is_allowed` flags

```go
func IsActionAllowedOnKeySetResource(
  ctx context.Context,
  clientSet clients.Interface,
  jwtAssertion string,
  orgUuid, projectUuid, componentUuid, envTemplateId, requiredPermission string,
) (bool, error) {
  ctxWithJWT := metadata.NewOutgoingContext(
    ctx,
    metadata.Pairs("x-jwt-assertion", jwtAssertion),
  )
  resp, err := clientSet.AuthzServiceClient().
    IsActionAllowed(ctxWithJWT, &authz_service.IsActionAllowedRequest{
      RequiredPermission: requiredPermission,
      ActionContext: &authz_service.ActionContext{
        OrgUuid:         orgUuid,
        ProjectUuid:     projectUuid,
        ComponentUuid:   componentUuid,
        EnvironmentUuid: envTemplateId,
      },
    })
  if err != nil {
    return false, fmt.Errorf("error while checking authorization: %w", err)
  }
  return resp.IsAllowed, nil
}
```

- Errors in the gRPC call bubble up as HTTP 500
- A `false` response leads to HTTP 403 in handlers
- Handlers guard each key-set endpoint with this check

### 11.3.4 Mocking AuthZ Service

For unit tests, a mock client records calls and returns customizable responses.

```go
type ChoreoAuthorizationClientMock struct {
  // Set this func to control behavior:
  IsActionAllowedFunc func(
    ctx context.Context,
    in *IsActionAllowedRequest,
    opts ...grpc.CallOption,
  ) (*IsActionAllowedResponse, error)

  // Tracks all invocations:
  calls struct {
    IsActionAllowed []struct {
      Ctx  context.Context
      In   *IsActionAllowedRequest
      Opts []grpc.CallOption
    }
  }
  lockIsActionAllowed sync.RWMutex
}

func (m *ChoreoAuthorizationClientMock) IsActionAllowed(
  ctx context.Context,
  in *IsActionAllowedRequest,
  opts ...grpc.CallOption,
) (*IsActionAllowedResponse, error) {
  if m.IsActionAllowedFunc == nil {
    panic("mock IsActionAllowedFunc not set")
  }
  m.lockIsActionAllowed.Lock()
  m.calls.IsActionAllowed = append(m.calls.IsActionAllowed, struct {
    Ctx  context.Context
    In   *IsActionAllowedRequest
    Opts []grpc.CallOption
  }{ctx, in, opts})
  m.lockIsActionAllowed.Unlock()
  return m.IsActionAllowedFunc(ctx, in, opts...)
}

func (m *ChoreoAuthorizationClientMock) IsActionAllowedCalls() []struct {
  Ctx  context.Context
  In   *IsActionAllowedRequest
  Opts []grpc.CallOption
} {
  m.lockIsActionAllowed.RLock()
  defer m.lockIsActionAllowed.RUnlock()
  return m.calls.IsActionAllowed
}
```

- Generated by **moq** from the gRPC interface
- Tests inject this mock via `clients.InterfaceMock.AuthzServiceClientFunc`
- Call records enable assertions on context and request payload

This integration ensures that only authorized users can manage OAuth key-sets in the App Gateway, with clear error handling and full test coverage using mocks.