# 26. Configuration Schema/Mapping/Connection Services

## 26.1 Configuration Schema Service Client and Schema-Driven Validation ðŸŽ¯

This section covers the **Configuration Schema Service Client**, which fetches schema-driven configuration â€œmountsâ€ from an external control-plane service, and explains how those mounts flow through the application to drive validation and persistence.

### Configuration Schema Service Client

The **Configuration Schema Service Client** resides in `external-services/configuration-schema-service` and implements:

```go
// Client defines the interface to fetch schema mounts.
type Client interface {
  GetDeployConfigurationMounts(ctx context.Context,
    organizationId, projectId, componentId,
    deploymentTrackId, envTemplateId,
    commitHash, componentType string,
  ) (*GetConfigMountResponse, error)
}
```

- **Initialization**

```go
  func NewClient(httpClient *http.Client) Client {
    return &client{httpClient: httpClient}
  }
  var schemaServiceUrl = config.GetConfig().SchemaServiceURL
```

Creates a `Client` backed by a custom `http.Client` .

- **Core Method: GetDeployConfigurationMounts**
- Constructs a GET URL:

```plaintext
     {SchemaServiceURL}/projects/{projectId}/components/{componentId}/
     env-template/{envTemplateId}/deployment-track/{deploymentTrackId}/configurations/deploy
```

1. Attaches query parameters:
2. `commitHash`: Git commit to drive schema version
3. `componentType`: Type of component (e.g. â€œByocServiceâ€)
4. Sets headers:
5. `CorrelationIdHeader` from context for tracing
6. `org-uuid` to scope by organization
7. Executes request with a **10 s timeout** and **2 retries on 500** .

```go
  resp := &GetConfigMountResponse{}
  _, err = request.New(ctx, c.httpClient, req, http.StatusOK,
    request.Timeout(10*time.Second),
    request.RetryOnStatus(http.StatusInternalServerError),
    request.MaxRetries(2),
    request.LogFnName("configurationMount.GetDeployConfigurationMounts"),
  ).
    SetResult(resp).
    Send()
```

### Schema Data Structures

When successful, the service returns:

```go
type GetConfigMountResponse struct {
  ConfigMounts []ConfigMount
}
```

Each `ConfigMount` has the following key fields:

| Field | Type | Purpose |
| --- | --- | --- |
| **Key** | string | Env-var name or file key |
| **ValueRef** | string | Reference (e.g. secret path) |
| **MountPath** | string | Container path for file mounts |
| **TemplatedFileContent** | string | Rendered file contents |
| **FileType** | string | File format: `yaml`, `json`, `toml`, etc. |
| **Type** | string | Mount category: `ConfigMountTypeEnv` or `ConfigMountTypeFile` |


*(Field names and example values are derived from tests in `configuration_service_test.go`.) *

### Integration in Choreo API Service

In `choreo/bundles/app/configurationsvc/configuration_service.go`, the method `generateSchemaBasedDesiredConfigurators`:

1. Calls the schema client.
2. Iterates over `deployConfigMappings.ConfigMounts`.
3. Classifies each mount into **env** or **file** and populates a `SchemaConfig`:

```go
deployConfigMappings, err := svc.clientSet.SchemaServiceClient().
  GetDeployConfigurationMounts(...)
// ...
var schemaConfig SchemaConfig
for _, m := range deployConfigMappings.ConfigMounts {
  switch m.Type {
  case configurationschemaservice.ConfigMountTypeEnv:
    schemaConfig.configs.envs = append(
      schemaConfig.configs.envs,
      SchemaEnvConfig{Key: m.Key, ValueRef: m.ValueRef},
    )
  case configurationschemaservice.ConfigMountTypeFile:
    schemaConfig.configs.files = append(
      schemaConfig.configs.files,
      SchemaFileConfig{
        FileName:             m.Key,
        TemplatedFileContent: m.TemplatedFileContent,
        MountPath:            m.MountPath,
        FileType:             string(m.FileType),
      },
    )
  default:
    logctx.GetLogger(ctx).
      WithField("configurationType", m.Type).
      Warn("Ignoring unknown configuration type")
  }
}
schemaConfig.release = release
return schemaConfig, nil
```

### `SchemaConfig` Struct & Responsibilities

Defined in `choreo/bundles/app/configurationsvc/schema_config.go`, `SchemaConfig` implements the `configurator` interface:

```go
type SchemaConfig struct {
  configs struct {
    envs  []SchemaEnvConfig
    files []SchemaFileConfig
  }
  release       *app.AppEnvironment
  configuration *configuration.Configuration
}
```

Internal types:

```go
type SchemaEnvConfig struct {
  Key      string
  ValueRef string
}
type SchemaFileConfig struct {
  FileName             string
  FileType             string
  MountPath            string
  TemplatedFileContent string
}
```

Key methods:

- **EnsureConfiguration**

Persists all env-vars and files into a single `configuration.Configuration` record.

- **GetId**

Returns a human-readable identifier for logging.

- **DeleteConfiguration**

(No-op for schema configs.)

### Schema-Driven Validation & Persistence Flow

```mermaid
flowchart TD
  A[generateSchemaBasedDesiredConfigurators] -->|GET mounts| B[Schema Service]
  B -->|[]ConfigMount| C[SchemaConfig struct]
  C -->|EnsureConfiguration| D[ConfigurationRepository]
  D -->|Save/Update| E[MSSQL: configuration table]
```

1. **Fetch**: Schema service delivers validated mounts.
2. **Transform**: Application maps mounts â†’ `SchemaConfig`.
3. **Encode**: `SchemaConfig.encodeConfigsToBase64()` turns JSON into Base64.
4. **Persist**: `ConfigurationRepository.Save/Update` stores encoded data in `config_data` column.

This enforces that only schema-declared configurations are accepted and applied at runtime.

```card
{
    "title": "Schema-Driven Controls",
    "content": "All application configurations derive from a single external JSON schema service, ensuring consistency and validation."
}
```

---

**Dependencies & Relationships**

- Relies on `config.GetConfig().SchemaServiceURL` for endpoint.
- Uses `request.New` utilities for HTTP orchestration.
- Interacts with `configuration.ConfigurationRepository` for database persistence.
- Downstream, Kubernetes secrets and ConfigMaps are generated from persisted schema data.