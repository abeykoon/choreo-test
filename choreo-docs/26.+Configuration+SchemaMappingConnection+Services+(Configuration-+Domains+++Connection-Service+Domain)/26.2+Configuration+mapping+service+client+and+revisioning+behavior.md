# 26.2 Configuration Mapping Service Client and Revisioning Behavior

This section describes how the Rudder service interacts with the **Configuration Mapping Service** to fetch, create, and version configuration mappings, and how those mapping revisions are persisted in the release management deployment records.

## Purpose of the Configuration Mapping Client

The **Configuration Mapping Client** encapsulates HTTP calls to an external service that translates Choreo config-group values into container environment variables or file mounts. It:

- Retrieves existing mappings for a given release and environment.
- Creates or updates mappings, returning a new **revision**.
- Supports fetching a specific revision for precise rollbacks or promotions.

## Client Interface Overview

| Method | Description | Revision Parameter |
| --- | --- | --- |
| GetDeployConfigurationMappings | Fetches mappings for a deployment track and environment, optionally at a given revision. | `revision *int` appended as query |
| GetConfigMapping | Retrieves raw mapping payload by mapping ID, with optional revision override. | `revision *int` appended as query |
| CreateConfigMap | Creates or updates a mapping. Returns the new mapping, including its **Revision**. | Revision embedded in request body |


```go
// Client defines the Configuration Mapping Service interface.
type Client interface {
  GetDeployConfigurationMappings(ctx context.Context,
    organizationId, projectId, componentId,
    deploymentTrackId, envTemplateId string,
    revision *int,
  ) (*DeployConfigurationMappingResponse, error)

  CreateConfigMap(ctx context.Context,
    orgId string,
    params CreateConfigMapRequest,
  ) (*ConfigurationMapping, error)

  GetConfigMapping(ctx context.Context,
    configMappingRequest GetConfigMappingRequest,
    revision *int,
  ) (*ConfigurationMapping, error)
}
```

## Revision Parameter Usage ðŸ”„

- When **`revision`** is non-nil, the client appends it as a query parameter:

```go
  if revision != nil {
    query["revision"] = strconv.FormatInt(int64(*revision), 10)
  }
```

- A `nil` revision requests the latest mapping.
- Revisioning enables consistent rollbacks, promotions, and drift detection.

## Creating and Updating Configuration Mappings âœï¸

The `CreateConfigMap` method sends a **POST** to `/configs/mappings`, carrying the modified mapping payload. A helper restructures the payload, stripping internal fields and preserving only the necessary values:

```go
func buildCreateConfigMapRequest(ctx context.Context, configMapping ConfigurationMapping) ConfigurationMapping {
  // Clone and flatten Values, drop nils
  newConfigMapping := configMapping
  // â€¦ iterate over configMapping.Configurations â€¦
  logctx.GetLogger(ctx).
    WithFields(logrus.Fields{"configMapping": newConfigMapping}).
    Infoln("Config mapping update payload")
  return newConfigMapping
}
```

Upon success, the service returns a `ConfigurationMapping` object with its **Revision**:

```json
{
  "mappingId": "...",
  "revision": 3,
  "configurations": [ â€¦ ]
}
```

## Revision Tracking in Release Deployments ðŸš€

After obtaining a new mapping revision, Rudder updates the **release management deployment** record to persist this version. The workflow is:

1. **Fetch existing deployment config**

```go
   existing, _ := c.releaseManagementController.GetComponentDeploymentConfigs(
     ctx, releaseMgtDeploymentID,
   )
   configMappingRev = existing.ConfigMappingRevision
```

1. **Invoke ****`RenameConnectionEnvVariable`** (or other mapping operations), passing `configMappingRev`.
2. **Receive ****`updatedConfigMappingRevision`** as `*int`.
3. **Update the deployment record** with the new revision:

```go
   c.releaseManagementController.UpdateDeploymentConfig(ctx,
     releaseMgtDeploymentID,
     ComponentDeploymentConfigRequest{
       ApiSettings:            json.RawMessage(existing.ApiSettings),
       ConfigMappingRevision:  *updatedConfigMappingRevision,
       SchemaBasedConfigRevision: existing.SchemaBasedConfigRevision,
     },
   )
```

### Persistence in the Database

The **release_deployments** table includes a column `config_mapping_revision`. It is populated during:

- **Initial deployment** via the `DeployRelease` API, using the `ConfigMappingRevision` field in `DeployReleaseRequest`:

```go
  type DeployReleaseRequest struct {
    EnvironmentID              UniqueIdentifier `json:"environment_id"`
    ComponentConfigs           *ComponentDeploymentConfigRequest `json:"component_configs,omitempty"`
  }
  type ComponentDeploymentConfigRequest struct {
    ConfigMappingRevision     int    `json:"config_mapping_revision"`
    SchemaBasedConfigRevision int    `json:"schema_based_config_revision"`
    ApiSettings               json.RawMessage `json:"api_settings,omitempty"`
  }
```

- **Retrieval** via `GET /releases/{releaseMgtID}/deployments/{releaseDeploymentID}/configs`, which returns:

```json
  {
    "component_configs": {
      "config_mapping_revision": 3,
      "schema_based_config_revision": 5,
      "api_settings": "{ â€¦ }"
    }
  }
```

These persistences ensure that each deployment record tracks the exact mapping revision applied, enabling auditability and precise rollbacks.

## Data Models

**DeployConfigurationMappingResponse**

```go
type DeployConfigurationMappingResponse struct {
  OrganizationId        string `json:"organizationId"`
  ProjectId             string `json:"projectId"`
  ComponentUuid         string `json:"componentId"`
  EnvironmentTemplateId string `json:"envTemplateId"`
  DeploymentTrackId     string `json:"deploymentTrackId"`
  MappingId             string `json:"mappingId"`
  Revision              *int   `json:"revision,omitempty"`
  Configurations        []struct { â€¦ } `json:"configurations"`
}
```

**ConfigurationMapping**

```go
type ConfigurationMapping struct {
  ComponentId       string                `json:"componentId"`
  Configurations    []MappingConfiguration `json:"configurations"`
  EnvTemplateId     string                `json:"envTemplateId"`
  ProjectId         string                `json:"projectId"`
  Revision          *int                  `json:"revision,omitempty"`
  // â€¦ timestamps â€¦
}
```

## Sequence Diagram

```mermaid
sequenceDiagram
  actor Rudder
  participant Client as ConfigMappingClient
  participant Service as External ConfigMapping API
  participant RM as ReleaseManagementController

  Rudder->>Client: GetDeployConfigurationMappings(ctx, â€¦, rev=nil)
  Client->>Service: HTTP GET /configs/mappings/deploy?â€¦ 
  Service-->>Client: 200 { revision: 2, â€¦ }
  Client-->>Rudder: DeployConfigurationMappingResponse

  Rudder->>Client: CreateConfigMap(ctx, org, params{Revision:2})
  Client->>Service: HTTP POST /configs/mappings {â€¦}
  Service-->>Client: 201 { revision: 3, â€¦ }
  Client-->>Rudder: ConfigurationMapping{Revision:3}

  Rudder->>RM: UpdateDeploymentConfig(ctx, depID,
    {ConfigMappingRevision:3, â€¦})
  RM-->>DB: UPDATE release_deployments SET config_mapping_revision=3
  RM-->>Rudder: Success
```

This flow ensures that every mapping change is versioned and tightly coupled to the release deployment record.