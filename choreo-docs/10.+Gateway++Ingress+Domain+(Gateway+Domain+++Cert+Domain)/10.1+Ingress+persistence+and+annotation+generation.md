# 10. Gateway / Ingress Domain (Gateway Domain + Cert Domain)

This section describes how **Ingress** resources are persisted in the database and how Kubernetes Ingress manifestsâ€”complete with controllerâ€specific and TLS annotationsâ€”are generated. It covers:

- Ingress model and GORM migrations
- JSON serialization helpers
- Annotation generation for NGINX (gateway) and TLS
- Deployment via the Ingress deployer

---

## 10.1 Ingress persistence and annotation generation

Ingress persistence and annotation generation involve four main components:

1. Ingress model (fields, Save/Get/Delete)
2. DB driver helpers (JSON â†” SQL serialization)
3. Annotation generator (NGINX + TLS)
4. Ingress deployer (manifest assembly & kubectl request)

```mermaid
flowchart LR
    IM[Ingress Model] -->|Save/Create| DB[(MSSQL DB)]
    DB -->|Load/Take| IM
    IM -->|GetIngressControllerAnnotations| AG[Annotation Generator]
    AG -->|map[string]string| AC[Controller Annotations]
    IM -->|GetAnnotations/GetTlsAnnotations| AA[Custom & TLS Annotations]
    AC & AA --> MB[Manifest Builder<br/>(generator.Ingress)]
    MB --> DEPLOY[Deployer<br/>(DeployToCluster/Env)]
```

---

## Ingress model & persistence

The `Ingress` struct represents a Choreo ingress resource. It includes gateway settings, DNS hosts, service backends, and custom metadata.

| Field | Type | Purpose |
| --- | --- | --- |
| **IngressType** | string | Controller type (e.g., `"NGINX"`) |
| **DNS** | `common.PostgresStringArray` | Hostnames for the Ingress rules |
| **ServiceMap** | `IngressServiceMapArray` | HTTP path â†’ service backend |
| **Annotations** | `common.PostgresMapStringString` | Static annotations set by the API request |
| **CustomAnnotations** | `common.PostgresMapStringString` | User-provided annotations preserved on update |
| **IngressConfig** | `IngressConfig` | Backend protocol, ingress class, whitelist IPs |
| **ClusterIssuer** | *string | Cert-manager issuer for Letâ€™s Encrypt |
| **SecretName** | *string | TLS secret (generated or custom) |
| **TimeHash** | int64 | Timestamp suffix for secret name hashing |


Key methods:

- `Save(ctx)`

Persists a new record via GORM:

```go
  func (obj *Ingress) Save(ctx context.Context) error {
      if dbc := db.DB(ctx).Create(&obj); dbc.Error != nil { return dbc.Error }
      logrus.Infof("Ingress:Save success for %s", obj.ID.String())
      return nil
  }
```

- `Get(id)` / `Delete(ctx)`

Standard load and delete operations using GORM.

- `SetKubernetesName()`, `GenerateTimeHash()`

Ensure unique resource names and secrets.

---

## JSON â†” SQL driver helpers

Custom types serialize to/from JSON strings in the DB. This allows storing arrays and structs in NVARCHAR columns.

```go
func (a IngressConfig) Value() (driver.Value, error) {
    val, err := json.Marshal(a)
    return string(val), err
}
func (a *IngressConfig) Scan(value interface{}) error {
    str, ok := value.(string)
    if !ok { return errors.New("IngressConfig type assertion failed") }
    return json.Unmarshal([]byte(str), &a)
}
```

```go
func (a IngressServiceMapArray) Value() (driver.Value, error) { /* ... */ }
func (a *IngressServiceMapArray) Scan(value interface{}) error { /* ... */ }
```

---

## Database migrations

GORMigrate scripts ensure the `ingresses` table supports new fields:

| Migration ID | Change |
| --- | --- |
| 0.0.197 | `ALTER TABLE ingresses ADD custom_annotations nvarchar(max)` |


This adds support for user-supplied annotations persisted in `CustomAnnotations`.

---

## NGINX and TLS annotation generation

Ingress annotations fall into two categories:

1. **Controller annotations** (e.g., NGINX settings)
2. **TLS annotations** (e.g., cert-manager hints)

### ðŸŽ¯ Controller annotations

`GenerateNginxAnnotations` produces standard NGINX Ingress Controller settings:

```go
func GenerateNginxAnnotations(cfg IngressConfig, https bool) map[string]string {
    m := make(map[string]string)
    if cfg.IngressClassName==nil {
        m["kubernetes.io/ingress.class"]="nginx"
    }
    m["nginx.ingress.kubernetes.io/affinity"]="cookie"
    m["nginx.ingress.kubernetes.io/backend-protocol"]=cfg.BackendProtocol
    // ... proxy-body-size, buffer-size, session-cookie, whitelist, etc.
    if https {
        m["nginx.ingress.kubernetes.io/ssl-redirect"]="true"
    }
    return m
}
```

- Defaults to `"nginx"` class if none specified
- Sets load-balancing, size limits, protocol, IP whitelisting

### ðŸ”’ TLS annotations

TLS annotations enable HTTPS and Letâ€™s Encrypt:

```go
func (obj *Ingress) GetTlsAnnotations() map[string]string {
    m := make(map[string]string)
    if obj.GetSecretName()!="" {
        m["ingress.kubernetes.io/ssl-redirect"]="true"
        m["kubernetes.io/tls-acme"]="true"
    }
    if issuer:=obj.ClusterIssuer; issuer!=nil && *issuer!="" {
        m["cert-manager.io/cluster-issuer"] = *issuer
        m["certmanager.k8s.io/cluster-issuer"] = *issuer
    }
    return m
}
```

- Enables SSL redirect when a secret is present
- Instructs Cert-Manager to use the specified `ClusterIssuer`

---

## Ingress deployer & manifest assembly

The deployer collects rules, annotations, labels, and TLS settings to build a `generator.Ingress` manifest:

```go
func (d deployer) KubernetesIngressRequest(ctx, obj, method, dryRun, target) (*generator.Ingress, error) {
    ing := generator.Ingress{
        Spec: generator.IngressSpec{
            IngressClassName: obj.IngressConfig.IngressClassName,
            Rules:            obj.GetHostRules(),
            TLS:               obj.GetTLSRules(),
        },
        Metadata: generator.Metadata{
            Name:      obj.KubernetesName,
            Namespace: obj.Namespace,
        },
    }
    ing.Metadata.SetLabels(obj.GetLabels())
    ing.Metadata.SetAnnotations(obj.GetIngressControllerAnnotations())
    ing.Metadata.SetAnnotations(obj.GetAnnotations())
    ing.Metadata.SetAnnotations(obj.GetTlsAnnotations())
    // deploy to environment or cluster
}
```

- **`GetHostRules`**: converts `ServiceMap` to HTTP paths
- **`SetAnnotations`**: merges controller, custom, and TLS annotations
- **`SetLabels`**: includes `ingress_id` plus any user labels
- Chooses target via `obj.EnvironmentID` or `obj.ClusterID`

---

## Summary

Ingress persistence and annotation generation in Rudder ties together:

- **Database schema** (via GORM and migrations)
- **Model serialization** (JSON driver helpers)
- **Annotation generation** (gateway + TLS)
- **Manifest assembly and deployment**

This ensures that Choreo HTTP APIs consistently produce Kubernetes Ingress resources with correct routing rules, annotations, and certificates for production environments.