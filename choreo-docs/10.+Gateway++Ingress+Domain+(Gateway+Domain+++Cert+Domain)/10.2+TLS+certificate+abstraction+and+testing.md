## 10 Gateway / Ingress Domain (Gateway Domain + Cert Domain)

### 10.2 TLS certificate abstraction and testing

This section describes how Rudder models and validates TLS certificates, and how those abstractions integrate into the Gateway/Ingress domain flows.

---

### üì¶ TLS Certificate Types

**TlsCert** bundles raw TLS material received or stored by the control plane:

```go
type TlsCert struct {
  CACertificate  string
  TLSCertificate string
  TLSKey         string
}
```

**CertInfo** holds parsed data extracted from a certificate chain:

```go
type CertInfo struct {
  CertDomains []string    // DNS names in leaf certificate
  CA          string      // Issuer organization or RDN sequence
  CreatedDate time.Time   // NotBefore timestamp
  ExpiryDate  time.Time   // NotAfter timestamp
  leafCert    *x509.Certificate
}
```

These types form the core abstraction for certificate management .

---

### üß© Validator Interface

Rudder defines a **Validator** to decouple parsing and verification logic:

```go
//go:generate moq -out tls_cert_mock.go . Validator
type Validator interface {
  ParseTlsCertificate(cert TlsCert) (CertInfo, error)
  VerifyDomainName(c CertInfo, domain string) error
}
```

- **ParseTlsCertificate** builds a `CertInfo` from raw PEM-encoded data.
- **VerifyDomainName** ensures the leaf certificate covers a given hostname via `leafCert.VerifyHostname`.

**NewCertValidator** returns the production implementation.

---

### ‚öôÔ∏è Production Implementation

The `validator` type implements `Validator`:

```go
func (*validator) ParseTlsCertificate(cert TlsCert) (CertInfo, error) {
  info := CertInfo{}
  // Combine leaf + CA PEM blocks
  bundle := cert.TLSCertificate
  if cert.CACertificate != "" {
    bundle = fmt.Sprintf("%s\n%s", cert.TLSCertificate, cert.CACertificate)
  }
  // Reject encrypted keys early
  if strings.Contains(cert.TLSKey, "BEGIN ENCRYPTED PRIVATE KEY") {
    return info, errors.New(ERR_ENCRYPTED_PRIVATE_KEY)
  }
  // Parse key pair and X.509 certificate
  tlsCert, err := tls.X509KeyPair([]byte(bundle), []byte(cert.TLSKey))
  if err != nil {
    return info, err
  }
  leaf, err := x509.ParseCertificate(tlsCert.Certificate[0])
  if err != nil {
    return info, err
  }
  if leaf == nil {
    return info, errors.New(ERR_UNKNOWN_FAILURE)
  }
  // Populate CertInfo
  info.CertDomains = leaf.DNSNames
  info.CreatedDate = leaf.NotBefore
  info.ExpiryDate  = leaf.NotAfter
  info.leafCert    = leaf
  // Derive CA name
  if len(leaf.Issuer.Organization) > 0 {
    info.CA = leaf.Issuer.Organization[0]
  } else {
    info.CA = leaf.Issuer.ToRDNSequence().String()
    if strings.Contains(info.CA, "CN=cert-manager.local") {
      return info, errors.New(ERR_CERT_MANAGER_CERT)
    }
  }
  // Reject self-signed CAs
  if leaf.IsCA {
    return info, errors.New(ERR_SELF_SIGNED_CERT)
  }
  return info, nil
}

func (*validator) VerifyDomainName(c CertInfo, domain string) error {
  return c.leafCert.VerifyHostname(domain)
}
```

Error constants used during parsing:

| Constant | Description |
| --- | --- |
| ERR_ENCRYPTED_PRIVATE_KEY | Key is encrypted, cannot parse |
| ERR_UNKNOWN_FAILURE | Leaf certificate data missing |
| ERR_CERT_MANAGER_CERT | Temporary cert from cert-manager detected |
| ERR_SELF_SIGNED_CERT | Certificate is a CA/self-signed |


---

### üß™ Unit Testing with Mocks

A mock `ValidatorMock` is generated via `moq` to support deterministic tests :

```go
type ValidatorMock struct {
  ParseTlsCertificateFunc func(cert TlsCert) (CertInfo, error)
  VerifyDomainNameFunc    func(c CertInfo, domain string) error
  // call tracking fields omitted for brevity
}
```

- The mock panics if a `nil` method is invoked.
- Call trackers (`ParseTlsCertificateCalls`, `VerifyDomainNameCalls`) allow verifying invocation counts and arguments.

---

### ‚úîÔ∏è Test Cases (`tls_cert_test.go`)

Tests validate core parsing and domain-verification scenarios :

1. **TestValidCertParse**
2. Loads a valid key (`tls.key`), certificate (`tls.crt`), and expected domain (`domain.txt`).
3. Asserts `ParseTlsCertificate` returns non-error and that `VerifyDomainName` succeeds.

1. **TestSelfSignedCertParse**
2. Parses a self-signed cert.
3. Expects error `ERR_SELF_SIGNED_CERT`.

1. **TestEncryptedCertParse**
2. Uses an encrypted private key.
3. Expects error `ERR_ENCRYPTED_PRIVATE_KEY`.

---

### üîó Integration Points in Gateway/Ingress Flows

Rudder‚Äôs **Ingress** model incorporates TLS material into Kubernetes ingress resources:

```go
func (obj *Ingress) GetTLSRules() []generator.IngressTLS {
  return []generator.IngressTLS{{
    Hosts:      obj.DNS,
    SecretName: obj.GetSecretName(),
  }}
}
```

```go
func (obj *Ingress) GetTlsAnnotations() map[string]string {
  m := make(map[string]string)
  if obj.GetSecretName() != "" {
    m["ingress.kubernetes.io/ssl-redirect"] = "true"
    m["kubernetes.io/tls-acme"]          = "true"
  }
  if obj.ClusterIssuer != nil && *obj.ClusterIssuer != "" {
    m["cert-manager.io/cluster-issuer"]     = *obj.ClusterIssuer
    m["certmanager.k8s.io/cluster-issuer"] = *obj.ClusterIssuer
  }
  return m
}
```

- **GetTLSRules** binds hosts to a Kubernetes secret.
- **GetTlsAnnotations** adds Cert-Manager annotations when a ClusterIssuer is specified.

---

### üîÑ Domain Validation API

Custom domain operations leverage the same `Validator` abstractions. For example, the **Validate Custom Domain** endpoint checks DNS coverage in the certificate:

```api
{
    "title": "Validate Custom Domain",
    "description": "Validate a custom domain",
    "method": "GET",
    "baseUrl": "https://api.choreo.example.com",
    "endpoint": "/api/v1/choreo/domains/validate",
    "headers": [
        {
            "key": "organizationId",
            "value": "<uuid>",
            "required": true
        }
    ],
    "queryParams": [
        {
            "key": "domain",
            "value": "Domain name",
            "required": true
        }
    ],
    "pathParams": [],
    "bodyType": "none",
    "requestBody": "",
    "formData": [],
    "rawBody": "",
    "responses": {
        "200": {
            "description": "Domain validation result",
            "body": "{\"data\":{\"valid\":true,\"message\":\"OK\"}}"
        }
    }
}
```

This route invokes `ParseTlsCertificate` (for uploaded or managed certs) and `VerifyDomainName` under the hood .

---

### üîç Certificate Validation Flow

```mermaid
flowchart TD
  A[Receive TlsCert Payload] --> B[ParseTlsCertificate]
  B --> C{Parsing Result}
  C -->|error| D[Return Parsing Error]
  C -->|success| E[CertInfo]
  E --> F[VerifyDomainName(domain)]
  F -->|error| G[ValidationFailed Response]
  F -->|success| H[ValidationSuccess Response]
```

- **A**: Controller accepts raw PEM-encoded TLS materials.
- **B‚ÄìC**: Parsing extracts domains, dates, CA and verifies structure.
- **E‚ÄìH**: Domain verification enforces that the certificate covers the requested host.

This completes the TLS certificate abstraction and testing documentation for the Gateway / Ingress Domain section.