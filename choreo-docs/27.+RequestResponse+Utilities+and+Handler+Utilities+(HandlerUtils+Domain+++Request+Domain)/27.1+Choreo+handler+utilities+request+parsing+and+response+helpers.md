# 27. Request/Response Utilities and Handler Utilities

This section describes the **HandlerUtils** domain in Choreoâ€™s Go HTTP API service. It covers:

- How HTTP handlers are wrapped and annotated with operation names
- How request data (path-, query-, body-params) is parsed and validated
- How responses and errors are serialized as JSON

These utilities enforce a consistent handler structure, centralized logging, and uniform request/response formats across all Choreo endpoints.

---

## 27.1 Choreo Handler Utilities: Request Parsing and Response Helpers

Choreo defines two core packages under `choreo/handlerutils`:

1. **Handler Initialization** (`handler_init.go`)
2. **Request Domain** (`request_data.go` + tests)
3. **Response Helpers** (`response_fns.go`)

Together, they standardize how handlers are constructed, how requests are decoded, and how responses are written.

---

## Handler Initialization

File: `choreo/handlerutils/handler_init.go`

This utility wraps every `http.HandlerFunc` to:

- Set an `operation` field in the access log
- Inject the **action name** into the request context

| Function | Purpose |
| --- | --- |
| **NewHandler** | Wraps a handler with logging and context-injection for the given action name |
| getActionNameFromCtx | Retrieves the action name from context (for error logging) |


```go
// NewHandler wraps fn to set access-log and context action
func NewHandler(fn http.HandlerFunc, action string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        middlewares.SetAccessLogField(r, "operation", action)
        ctx := context.WithValue(r.Context(), actionNameKey{}, action)
        fn(w, r.WithContext(ctx))
    }
}

// getActionNameFromCtx reads action name from context
func getActionNameFromCtx(ctx context.Context) string {
    if action, ok := ctx.Value(actionNameKey{}).(string); ok {
        return action
    }
    return "UNKNOWN"
}
```

Key points:

- **Access log** gets an `"operation"` field set to `action`.
- Downstream code (e.g., `RespondWithError`) uses `getActionNameFromCtx` for structured error logging.

---

## Request Domain

File: `choreo/handlerutils/request_data.go`

The **RequestDataReader** encapsulates parsing and validation of path, query, and body parameters. It tracks whether any parsing error occurred and short-circuits further reads.

### Core Types & Constructor

```go
// NewRequestDataReader returns a fresh reader
func NewRequestDataReader() *reqDataReader { return &reqDataReader{} }

type reqDataReader struct {
    hasErrors bool
}
```

### Methods

| Method | Behavior |
| --- | --- |
| ReadPathParam(w,r,name) | Reads `/{name}`; on missing â†’ 400 + error response, sets `hasErrors` |
| ReadUUIDPathParam(w,r,name) | Converts path-param to `common.UniqueIdentifier`; on invalid UUID â†’ 400 + error |
| DecodeQueryParams(w,r,target) | Uses Gorilla Schema to decode `r.URL.Query()` into `target`; on error â†’ 400 |
| DecodeRequestBody(w,r,target) | JSON-decodes `r.Body` into `target`; on error â†’ 400 |
| HasErrors() bool | Returns whether any prior read/decode failed |
| GetPagination(r) (offset,limit) | Parses `offset` and `limit` query params with defaults `0` and `50` |


### Usage Example

```go
func CreateEgressPolicy(w http.ResponseWriter, r *http.Request) {
    s := handlerutils.NewRequestDataReader()

    // Read path/query/body
    body := network_policy.EgressPolicyRequest{}
    s.DecodeRequestBody(w, r, &body)

    if s.HasErrors() {
        return  // early exit; error already sent
    }

    // Business logic...
    policy, err := ctrl.CreateEgressPolicy(r.Context(), body)
    if err != nil {
        handlerutils.RespondWithError(w, r, 500, err)
        return
    }
    handlerutils.RespondWithJSON(w, 201, policy)
}
```

This pattern eliminates repetitive error checks and manual response writes.

---

## Response Helpers

File: `choreo/handlerutils/response_fns.go`

These functions standardize JSON responses and error handling:

### RespondWithJSON

- Marshals `payload` under key `"data"` when status < 300, otherwise `"errors"`
- Sets `Content-Type: application/json` and writes the HTTP status code

```go
func RespondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
    key := "data"
    if code >= 300 {
        key = "errors"
    }
    resp, _ := json.Marshal(map[string]interface{}{key: payload})
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    w.Write(resp)
}
```

### RespondWithError

- Determines status and payload from `common.RequestError` or generic `error`
- Logs at Info for 4xx, Error for 5xx with correlation ID and action name
- Delegates to `RespondWithJSON`

```go
func RespondWithError(w http.ResponseWriter, r *http.Request, defaultCode int, err error) {
    action := getActionNameFromCtx(r.Context())
    logger := logctx.From(r.Context()).
        WithField("log_type","request_err").
        WithField("action", "["+action+"]")

    var payload interface{}
    code := defaultCode

    if reqErr, ok := err.(common.RequestError); ok {
        code = reqErr.StatusCode
        payload = reqErr.GetPayload()
    } else {
        reqId := common.GetRequestIdFromContext(r.Context())
        msg := err.Error()
        if code == 500 {
            msg = "Internal Server Error"
        }
        payload = map[string]interface{}{
            "message":        msg,
            "correlation_id": reqId,
        }
        logger = logger.WithError(err)
    }

    level := logrus.InfoLevel
    if code >= 500 {
        level = logrus.ErrorLevel
    }
    logger.WithField("status", code).Logf(level, "%s %s", r.Method, r.URL)

    RespondWithJSON(w, code, payload)
}
```

---

## Integration in Controllers

File: `choreo/handlers/controller_init.go`

Although business controllers are initialized here, route registration leverages **NewHandler** to wrap every handler. For example, in a Chi router:

```go
r.Get("/egress", handlerutils.NewHandler(handlers.GetEgressPolicy, "LIST_EGRESS_POLICY"))
r.Post("/egress", handlerutils.NewHandler(handlers.CreateEgressPolicy, "CREATE_EGRESS_POLICY"))
```

This ensures every request:

1. Logs the `"operation"` via middleware
2. Injects `"operation"` into `context.Context`
3. Enables downstream error logging to include action name consistently

---

ðŸŽ¯ **Summary**

Choreoâ€™s **HandlerUtils** domain provides a cohesive framework for:

- **Wrapping handlers** with consistent logging and context (`NewHandler`)
- **Reading and validating** request data (path, query, body) via a stateful reader
- **Serializing** both success and error responses with structured JSON and logs

By centralizing these patterns, Choreo ensures uniform behavior, reduces boilerplate, and simplifies maintenance across its HTTP API surface.