# 27.2 API Handler Patterns and Shared Response Modeling

This section describes the common patterns used across all HTTP API handlers in `api/handlers/*` and how they rely on the **HandlerUtils** domain for request decoding, error handling, and response normalization. These patterns ensure consistent behavior, logging, and JSON envelopes across the entire service.

## 1. Request Decoding and Validation

All handlers begin by extracting and validating inputs—path parameters, query parameters, and request bodies—using one of two approaches:

- **Manual extraction** for simple UUIDs:
- Use `chi.URLParam` and `common.UUIDFromString`.
- On parse failure, call `RespondWithError(w, r, 400, err)` and return.

Example in ResiliencyConfigGet:

```go
  strEpID := chi.URLParam(r, "epID")
  epID, err := common.UUIDFromString(strEpID)
  if err != nil {
      handlerutils.RespondWithError(w, r, 400, err)
      return
  }
```

- **Structured decoding** for multiple inputs:
- Create a reader:

```go
     s := handlerutils.NewRequestDataReader()
```

1. Read path params:

```go
     compID := s.ReadUUIDPathParam(w, r, "componentId")
```

1. Decode query params into a struct:

```go
     var q QueryParams
     s.DecodeQueryParams(w, r, &q)
```

1. Decode JSON body into a struct:

```go
     var body SomeRequest
     s.DecodeRequestBody(w, r, &body)
```

1. If any step fails, `HasErrors()` returns true and the handler returns immediately.

## 2. Service / Bundle Invocation

After inputs are validated, handlers delegate business logic to internal **bundles** or **controllers** under `choreo/bundles` or `internal/bundles`. Examples:

- **Code Server**

```go
  url, err := svc.CreateOrGetCodeServer(ctx, req, authToken)
```

- **Resiliency**

```go
  obj, err := resiliencyController.GetEpResiliencyConfig(ctx, release.ID, epID)
```

## 3. Error Handling with `RespondWithError`

All error cases funnel through:

```go
handlerutils.RespondWithError(w, r, defaultCode, err)
```

Behavior of `RespondWithError` (in `choreo/handlerutils/response_fns.go`):

- Detects `common.RequestError` and uses its `StatusCode` and structured payload.
- Otherwise:
- For **500**, returns

`{ "errors": { "message": "Internal Server Error", "correlation_id": "<id>" } }`

- For other codes, returns

`{ "errors": { "message": err.Error(), "correlation_id": "<id>" } }`

- Logs at **Info** level for `<500`; **Error** level for `>=500`.
- Always calls `RespondWithJSON` with the normalized payload.

## 4. Success and Error Response Modeling with `RespondWithJSON`

```go
func RespondWithJSON(w http.ResponseWriter, code int, payload interface{})
```

- Wraps the payload under a top-level key:
- **`"data"`** when `code <= 300`
- **`"errors"`** when `code > 300`
- Sets `Content-Type: application/json` and writes the HTTP status code.
- Example envelopes:

```json
  // Success (200)
  { "data": { /* ... */ } }

  // Created (201)
  { "data": { /* ... */ } }

  // Client error (400)
  { "errors": { "message": "...", "correlation_id": "..." } }

  // Server error (500)
  { "errors": { "message": "Internal Server Error", "correlation_id": "..." } }
```

## 5. HTTP Status Code Normalization

| Scenario | Function | Default Code | Envelope Key |
| --- | --- | --- | --- |
| **Success** | `RespondWithJSON` | 200–300 | `data` |
| **Creation** | `RespondWithJSON` | 201 | `data` |
| **Client error** | `RespondWithError` | 400 | `errors` |
| **Not found / forbidden** | `RespondWithError` | 403, 404 | `errors` |
| **Server/internal error** | `RespondWithError` | 500 | `errors` |


## 6. Example: Code Server Handler

```go
func CodeServerHandler(svc codeserver.Service) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        var req codeserver.CodeServerRequest
        if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
            handlerutils.RespondWithError(w, r, 500, err)
            return
        }
        url, err := svc.CreateOrGetCodeServer(r.Context(), req, authToken)
        if err != nil {
            handlerutils.RespondWithError(w, r, 500, err)
            return
        }
        handlerutils.RespondWithJSON(w, 201, CodeServerResponse{URL: url})
    }
}
```

- **Body decoding** → error
- **Service call** → error
- **Success** → 201 with `{"data": { "url": "…" }}`

---

This **API handler pattern**—composed of *request utilities*, *bundle invocation*, and *shared response modeling*—ensures every endpoint in Rudder behaves in a predictable, uniform manner.