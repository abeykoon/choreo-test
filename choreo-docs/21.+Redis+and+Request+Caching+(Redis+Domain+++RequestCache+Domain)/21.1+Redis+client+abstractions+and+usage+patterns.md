# 21. Redis and Request Caching (Redis Domain + RequestCache Domain)

This section describes how Rudder leverages Redis for cross-request and cross-component caching. The **Redis Domain** provides a pluggable client abstraction over `go-redis`, while the **RequestCache Domain** holds in-memory per-request data (covered elsewhere). Here we focus on the Redis client abstractions, configuration, and usage patterns.

## 21.1 Redis client abstractions and usage patterns

Rudder defines two layers of Redis integration:

- **RedisClientManager**: Builds and holds a pool of `redis.Client` instances per database index and dataplane (cluster) ID.
- **redisClient**: Implements a uniform interface over common Redis commands (strings, hashes, sets, ingress entries).

### File structure

| Path | Purpose |
| --- | --- |
| `external-services/redis-client-manager/redis-client-manager.go` | Manager of low-level `*redis.Client` instances ⚙️ |
| `external-services/redis/redis.go` | High-level Redis operations (`Interface`, `redisClient`) |
| `external-services/redis/types.go` | Domain types (`IngressEntry`) |
| `external-services/redis/redis_mock.go` | Generated mock for `Interface` in tests |


---

### RedisClientManager ⚙️

The `RedisClientManager` builds clients for:

- A **default** connection (empty cluster ID) for both **WebApp** (`DB=1`) and **App Gateway** (`DB=5`).
- **Per-cluster** connections using `RedisServer.Servers` list and each `DataPlaneId`.

Clients are configured with TLS, retry policy, and a name tag.

```go
func NewRedisClientManager(cfg config.RedisServer) *RedisClientManager {
    // onConnect sets client name “rudder”
    onConnectFunc := func(ctx context.Context, c *redis.Conn) error {
        return c.ClientSetName(ctx, clientName).Err()
    }
    tlsConfig := &tls.Config{ MinVersion: tls.VersionTLS12 }
    maxRetries, poolSize := 10, 3

    clients := make(map[clientKey]*redis.Client)
    // Default clients
    clients[clientKey{dbIndex: WebAppRedisIndex,  clusterId: common.EmptyUUID()}] =
        redis.NewClient(&redis.Options{ /* ... WebApp options ... */ })
    clients[clientKey{dbIndex: AppGwRedisDbIndex, clusterId: common.EmptyUUID()}] =
        redis.NewClient(&redis.Options{ /* ... App Gateway options ... */ })

    // Per-server clients
    for _, server := range cfg.Servers {
        webAppClient := redis.NewClient(&redis.Options{ /* server.Host, DB=1 */ })
        appGwClient  := redis.NewClient(&redis.Options{ /* server.Host, DB=5 */ })
        for _, dpID := range server.DataPlaneIds {
            clients[clientKey{dbIndex: WebAppRedisIndex,  clusterId: dpID}] = webAppClient
            clients[clientKey{dbIndex: AppGwRedisDbIndex, clusterId: dpID}] = appGwClient
        }
    }

    return &RedisClientManager{clients: clients}
}
```

All lookup logic is in `GetClient`, which first tries the exact `(dbIndex, clusterId)` key, then falls back to the default cluster ID.

---

### High-level Redis interface

```go
type Interface interface {
  SetIngressEntry(ctx context.Context, clusterId common.UniqueIdentifier, key string, value IngressEntry) error
  DeleteIngressEntries(ctx context.Context, clusterId common.UniqueIdentifier, keys ...string) error
  Set(ctx context.Context, clusterId common.UniqueIdentifier, key, value string) error
  Get(ctx context.Context, clusterId common.UniqueIdentifier, key string) (string, error)
  HSet(ctx context.Context, clusterId common.UniqueIdentifier, key string, metadata map[string]string) error
  HDel(ctx context.Context, clusterId common.UniqueIdentifier, key string, fields ...string) error
  SREM(ctx context.Context, clusterId common.UniqueIdentifier, key string, members ...interface{}) error
  SMEMBERS(ctx context.Context, clusterId common.UniqueIdentifier, key string) ([]string, error)
  Delete(ctx context.Context, clusterId common.UniqueIdentifier, keys ...string) error
}
func NewRedisClient(cm *RedisClientManager, dbIndex int) Interface {
  return &redisClient{cm, dbIndex}
}
```

The `redisClient` holds a pointer to the manager and a fixed `dbIndex`.

---

### Supported Redis operations

| Method | Description |
| --- | --- |
| `Set` | Store a string key/value |
| `Get` | Retrieve a string value |
| `HSet` | Set a hash (map) under a key |
| `HDel` | Remove fields from a hash |
| `SREM` | Remove members from a set |
| `SMEMBERS` | Read all members of a set |
| `Delete` | Delete one or more keys |
| `SetIngressEntry` | Marshal and store an `IngressEntry` JSON |
| `DeleteIngressEntries` | Delete ingress entries with backward-compatible key prefix |


All methods fetch the appropriate `*redis.Client` via `GetClient`, then invoke the command on that client. Errors are wrapped with context.

---

### IngressEntry type

Ingress entries store web-app routing metadata for App Gateway:

```go
type IngressEntry struct {
  IngressHostName        string   `json:"ingress_host_name"`
  OrganizationID         string   `json:"organization_id"`
  IsAppGatewayConfigured bool     `json:"is_app_gateway_configured"`
  ApiURL                 string   `json:"api_url"`
  UpstreamHost           string   `json:"upstream_host"`
  UpstreamPort           string   `json:"upstream_port"`
  ProtectedRoutes        []string `json:"protected_routes"`
}
```

---

### Usage patterns in Rudder

- **App Gateway Service**

The Choreo App Gateway bundle calls `HSet`/`HDel` to configure routes. It proxies calls via Mizzen for PDP-enabled clusters, then writes to Redis:

```go
  // in app_gateway_redis_service.go
  return s.clients.AppGwRedisClient().
             HSet(ctx, env.ClusterId, key, metadata)
```

- **Web App short-URL management**

The WebApp bundle invokes `SetIngressEntry` when creating public URLs and `DeleteIngressEntries` upon removal.

- **Per-data-plane sharding**

Clients are keyed by `clusterId`, allowing isolated caches per Kubernetes data plane.

---

### Mocking in tests

A `moq`-generated `InterfaceMock` implements the same `Interface`, capturing call arguments for assertions:

```go
// redis_mock.go (auto-generated)
type InterfaceMock struct {
  SetFunc              func(ctx context.Context, clusterId common.UniqueIdentifier, key, value string) error
  SetIngressEntryFunc  func(ctx context.Context, clusterId common.UniqueIdentifier, key string, value IngressEntry) error
  // … other methods …
}
```

This allows fine-grained unit tests of higher-level services without connecting to real Redis.

---

By centralizing client creation in `RedisClientManager` and exposing a simple `Interface`, Rudder ensures consistent configuration, per-cluster isolation, and easy mocking for day-2 operations and testing.