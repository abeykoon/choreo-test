# 16. Continuous Delivery Domain (Images, Registries, Webhooks)

## 16.2 Image processing pipeline and tests

This section covers the internal image processing pipeline used by Rudderâ€™s Continuous Delivery bundle. It explains how incoming image information is validated, normalized, and persisted, and then details the accompanying unit tests that verify correctness and idempotency.

---

### Pipeline Overview ðŸš€

```mermaid
flowchart TD
  A[Input: ByoiImageInfo & ImageRegistry] --> B[ValidateImageUrlBelongsToRegistry]
  B --> C[Parse name & tag via getImageNameAndTag]
  C --> D[Construct Image struct (MakeByoiImageForCollection)]
  D --> E[Persist Image to DB (ProcessByoiImageForCollection)]
  E --> F[Return created Image]
  
  subgraph ImportPath
    G[ImportImageToVersion] --> H[Fetch latest Image]
    H --> I[Copy fields into new Image]
    I --> J[Persist via ImageRepository.Create]
    J --> K[Return imported Image]
  end
```

---

### Function Summary

| Function | Purpose | Inputs | Output / Errors |
| --- | --- | --- | --- |
| **getImageNameAndTag** | Split `<name>:<tag>` into components | `imgNameWithTag string` | `(imgName string, tag string)` |
| **ValidateImageUrlBelongsToRegistry** | Ensure the URL contains a tag and matches registry host | `imageUrl, registryHost string` | `error` if missing tag or host mismatch |
| **MakeByoiImageForCollection** | Normalize BYOI info into an `Image` struct | `collection ImageRegistry`, `imageInfo ByoiImageInfo` | `(Image, error)` |
| **ProcessByoiImageForCollection** | Persist a new `Image` for a registry collection | `ctx context.Context`, `registry ImageRegistry`, `imageInfo ByoiImageInfo` | `(Image, error)` |
| **ImportImageToVersion** | Clone an existing `Image` into a new API version | `ctx context.Context`, `imageId, targetVersionId common.UniqueIdentifier` | `(Image, error)` |


---

## Detailed Functions

### getImageNameAndTag

Extracts the repository path and tag from a full image name.

```go
func getImageNameAndTag(imgNameWithTag string) (imgName, tag string) {
    slice := strings.Split(imgNameWithTag, ":")
    nameSlice := slice[0 : len(slice)-1]
    imgName = strings.Join(nameSlice, "")
    if len(slice) > 1 {
        tag = slice[len(slice)-1]
    }
    return
}
```

Splitting on `:` handles images like `repo/path:tag`.

---

### ValidateImageUrlBelongsToRegistry

Ensures the provided image URL includes a tag and (optionally) matches the registry host.

```go
func ValidateImageUrlBelongsToRegistry(imageUrl, registryHost string) error {
    parts := strings.Split(imageUrl, ":")
    if len(parts) < 2 {
        return errors.New("image url should contain tag")
    }
    if registryHost == "" {
        return nil
    }
    host := strings.Replace(registryHost, "https://", "", 1)
    if strings.HasPrefix(imageUrl, fmt.Sprintf("%s/", host)) {
        return nil
    }
    return errors.New("image url doesn't match registry host")
}
```

- Rejects URLs without `:<tag>`.
- Skips host check if `registryHost` is empty.

---

### MakeByoiImageForCollection

Constructs a normalized `Image` entity for BYOI (Bring Your Own Image).

```go
func MakeByoiImageForCollection(collection ImageRegistry, imageInfo ByoiImageInfo) (Image, error) {
    if err := ValidateImageUrlBelongsToRegistry(imageInfo.ImageNameWithTag, collection.ContainerRegistryUrl); err != nil {
        return Image{}, err
    }
    imgName, tagName := getImageNameAndTag(imageInfo.ImageNameWithTag)
    if tagName == "" {
        return Image{}, errors.New("tag not found in image name")
    }
    if imageInfo.TriggerSource != ByoiImageSourceManual && imageInfo.TriggerSource != ByoiImageSourceExternal {
        return Image{}, errors.New("invalid trigger source")
    }
    var ci []ClusterImageTagInfo
    if !collection.ContainerRegistryId.IsEmpty() {
        ci = append(ci, ClusterImageTagInfo{
            ImageNameWithTag: imageInfo.ImageNameWithTag,
            RegistryId:       collection.ContainerRegistryId,
        })
    }
    image := Image{
        XPlatformerData:       collection.XPlatformerData,
        BelongToImageRegistry: BelongToImageRegistry{ImageRegistryID: collection.ID},
        TagName:               tagName,
        ImageName:             imgName,
        ImageNameWithTag:      imageInfo.ImageNameWithTag,
        Status:                "SUCCESS",
        Tags:                  common.PostgresStringArray{tagName},
        ClusterImageInfoArray: ci,
        ApiVersionId:          imageInfo.ApiVersionId,
        TriggerSource:         string(imageInfo.TriggerSource),
    }
    image.EnsureID()
    return image, nil
}
```

- Enforces valid trigger source (`MANUAL` or `EXTERNAL`).
- Initializes cluster info if registry ID is present.

---

### ProcessByoiImageForCollection

Persists a new `Image` into the registry collection.

```go
func ProcessByoiImageForCollection(ctx context.Context, registry ImageRegistry, imageInfo ByoiImageInfo) (Image, error) {
    image, err := MakeByoiImageForCollection(registry, imageInfo)
    if err != nil {
        return Image{}, err
    }
    if err := ImageRepository.Create(ctx, &image); err != nil {
        return Image{}, err
    }
    return image, nil
}
```

- Always creates a new recordâ€”even if the tag already existsâ€”ensuring idempotent duplication.

---

### ImportImageToVersion

Duplicates an existing image record into another API version.

```go
func ImportImageToVersion(ctx context.Context, imageId, targetVersionId common.UniqueIdentifier) (Image, error) {
    latestImage, err := ImageRepository.GetById(ctx, imageId)
    if err != nil {
        return Image{}, err
    }
    image := Image{
        XPlatformerData:       latestImage.XPlatformerData,
        BelongToImageRegistry: BelongToImageRegistry{ImageRegistryID: latestImage.BelongToImageRegistry.ImageRegistryID},
        ApiVersionId:          targetVersionId,
        ImageNameWithTag:      latestImage.ImageNameWithTag,
        TagName:               latestImage.TagName,
        ImageName:             latestImage.ImageName,
        Status:                "SUCCESS",
        Tags:                  latestImage.Tags,
        ClusterImageInfoArray: latestImage.ClusterImageInfoArray,
        TriggerSource:         latestImage.TriggerSource,
    }
    image.EnsureID()
    if err := ImageRepository.Create(ctx, &image); err != nil {
        return Image{}, err
    }
    return image, nil
}
```

- Fetches the latest image, clones fields, and writes a fresh ID.

---

## Tests Overview ðŸ§ª

The file `process_image_test.go` defines unit tests that validate both pipeline behavior and idempotency.

```go
func TestProcessImageForCollection(t *testing.T) {
    // Setup: create a fresh ImageRegistry in the test DB
    projectInfo := common.XPlatformerData{...}
    imageReg := ImageRegistry{XPlatformerData: projectInfo, ...}
    db.DB().Save([]*ImageRegistry{&imageReg})
    comp1v1 := common.NewUUID()
    
    tests := []struct {
        name                     string
        args                     args
        want                     func(id common.UniqueIdentifier) Image
        wantImageCountInRegistry int
        wantErr                  bool
    }{
        {
            name: "add first image to registry",
            args: args{... TriggerSource: ByoiImageSourceManual},
            wantImageCountInRegistry: 1,
        },
        {
            name: "add an existing image tag to collection should create a new image",
            args: args{... TriggerSource: ByoiImageSourceExternal},
            wantImageCountInRegistry: 2,
        },
        {
            name: "add a new image tag to collection",
            args: args{... ImageNameWithTag: "abc/def:456"},
            wantImageCountInRegistry: 3,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ProcessByoiImageForCollection(tt.args.ctx, tt.args.registry, tt.args.imageInfo)
            ...
            imagesInReg, _ := ImageRepository.ListByImageCollectionId(tt.args.ctx, tt.args.registry.ID)
            if len(imagesInReg) != tt.wantImageCountInRegistry { ... }
            ...
        })
    }
}
```

Key points:

- **Database state** is reset per test run.
- **Idempotency**: repeated tags still create new records.
- **Assertions** compare sorted image lists and ignore volatile fields (`PlatformerTag`, timestamps).

---

### Test Scenarios

| Scenario | Trigger Source | Expected Images in Registry |
| --- | --- | --- |
| add first image to registry | MANUAL | 1 |
| add an existing image tag to collection should create a new image | EXTERNAL | 2 |
| add a new image tag to collection | EXTERNAL | 3 |


---

### Sample Assertion

```go
imagesInReg, err := ImageRepository.ListByImageCollectionId(ctx, registry.ID)
if err != nil {
    t.Fatal(err)
}
if len(imagesInReg) != wantCount {
    t.Errorf("got [%d] images, want [%d]", len(imagesInReg), wantCount)
}
```

This verifies both the **count** and the **content** of persisted `Image` entries.

---

**Summary:**

The **image processing pipeline** in Rudderâ€™s Continuous Delivery bundle ensures incoming image references are correctly validated, parsed, and persisted. The **unit tests** confirm error handling, normalization, and idempotent behavior when re-processing the same tag.